<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Decoding Lab: Neural Text Degeneration</title>
  <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
  <style>
    :root {
      --bg: #f3f7fb;
      --bg-alt: #e8eef7;
      --ink: #111827;
      --accent: #0b5fc6;
      --accent-2: #0f766e;
      --card: #ffffff;
      --muted: #5b677a;
      --ok: #166534;
      --bad: #b91c1c;
      --ring: #0b5fc633;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "IBM Plex Sans", "Avenir Next", "Segoe UI", "Helvetica Neue", sans-serif;
      color: var(--ink);
      background:
        radial-gradient(1000px 500px at 100% -10%, #d5e4fb 0%, transparent 70%),
        radial-gradient(900px 500px at 0% 110%, #d9eee8 0%, transparent 70%),
        linear-gradient(150deg, var(--bg), var(--bg-alt));
      min-height: 100vh;
    }

    header {
      padding: 20px 22px 14px;
      max-width: 1100px;
      margin: 0 auto;
      background: #ffffffd6;
      backdrop-filter: blur(10px);
      border: 1px solid #cfdced;
      border-radius: 14px;
      margin-top: 14px;
      box-shadow: 0 18px 38px #26374d16;
    }

    h1 {
      margin: 0;
      font-family: "Iowan Old Style", "Baskerville", "Times New Roman", serif;
      letter-spacing: 0.3px;
      font-size: clamp(1.8rem, 3vw, 2.6rem);
    }

    .subtitle {
      margin-top: 8px;
      color: var(--muted);
      font-size: 0.95rem;
    }

    .tabs {
      max-width: 1100px;
      margin: 10px auto 0;
      padding: 0 20px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    .tab-btn {
      border: 1px solid #c8d7ec;
      background: #f9fbff;
      color: var(--ink);
      padding: 10px 16px;
      border-radius: 12px;
      cursor: pointer;
      font-weight: 700;
      transition: all 160ms ease;
    }

    .tab-btn.active {
      background: var(--accent);
      border-color: var(--accent);
      color: #fff;
      box-shadow: 0 6px 20px var(--ring);
    }

    .tab-btn:hover {
      transform: translateY(-1px);
    }

    main {
      max-width: 1100px;
      margin: 12px auto 36px;
      padding: 0 20px;
    }

    .panel {
      display: none;
      background: var(--card);
      border: 1px solid #d8e3f0;
      border-radius: 14px;
      box-shadow: 0 16px 30px #1c2f4512;
      padding: 20px;
      animation: fade 300ms ease;
    }

    .panel.active {
      display: block;
    }

    @keyframes fade {
      from { opacity: 0; transform: translateY(4px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .grid {
      display: grid;
      grid-template-columns: 320px 1fr;
      gap: 14px;
    }

    .controls {
      background: #f9fbff;
      border: 1px solid #d7e1f0;
      border-radius: 12px;
      padding: 14px;
    }

    label {
      display: block;
      margin: 12px 0 6px;
      font-size: 0.88rem;
      color: var(--muted);
    }

    input[type="range"], select, textarea, input[type="text"] {
      width: 100%;
    }

    textarea, select, button, input[type="text"] {
      border: 1px solid #c5d7ec;
      border-radius: 10px;
      background: #ffffff;
      padding: 10px;
      font: inherit;
      color: inherit;
    }

    textarea {
      min-height: 92px;
      resize: vertical;
    }

    button {
      cursor: pointer;
      font-weight: 700;
      background: linear-gradient(180deg, #ffffff, #edf4ff);
      transition: transform 160ms ease, box-shadow 160ms ease;
    }

    button.primary {
      background: linear-gradient(180deg, #1677ff, #0b5fc6);
      color: #fff;
      border-color: #0b5fc6;
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 20px #33557f1a;
    }

    button:disabled {
      cursor: not-allowed;
      opacity: 0.65;
      transform: none;
      box-shadow: none;
    }

    .stack > * + * {
      margin-top: 10px;
    }

    .card {
      background: #fcfdff;
      border: 1px solid #d8e3f0;
      border-radius: 12px;
      padding: 12px;
    }

    .control-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-size: 0.82rem;
      color: var(--muted);
      padding: 6px 2px 2px;
      border-bottom: 1px solid #e3ebf6;
      margin-bottom: 8px;
    }

    .output-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 12px;
    }

    .mono {
      font-family: ui-monospace, Menlo, Consolas, monospace;
      font-size: 0.88rem;
      white-space: pre-wrap;
      line-height: 1.45;
    }

    .metrics {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 8px;
    }

    .metric {
      background: #edf4ff;
      border: 1px solid #d3e2f6;
      padding: 6px 8px;
      border-radius: 999px;
      font-size: 0.8rem;
    }

    .arena {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 12px;
      margin-top: 12px;
    }

    .arena button {
      text-align: left;
      min-height: 170px;
    }

    .arena h4 {
      margin: 0 0 8px;
      font-family: "Baskerville", serif;
      font-size: 1.1rem;
    }

    .score {
      margin-top: 10px;
      color: var(--muted);
      font-size: 0.9rem;
    }

    .result.ok { color: var(--ok); font-weight: 700; }
    .result.bad { color: var(--bad); font-weight: 700; }

    .chart-wrap {
      display: grid;
      grid-template-columns: 1fr 320px;
      gap: 14px;
    }

    .chart-surface {
      position: relative;
    }

    #tailChart {
      width: 100%;
      height: 360px;
      border: 1px solid #d8e3f0;
      border-radius: 12px;
      background: #ffffff;
    }

    .legend {
      font-size: 0.9rem;
      color: var(--muted);
      line-height: 1.5;
    }

    .kpi {
      background: #edf4ff;
      border: 1px solid #d3e2f6;
      border-radius: 10px;
      padding: 8px;
      margin-top: 8px;
    }

    .status {
      font-size: 0.82rem;
      color: var(--muted);
      min-height: 1.2em;
    }

    @media (max-width: 940px) {
      .grid, .chart-wrap {
        grid-template-columns: 1fr;
      }
      .output-grid, .arena {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Decoding Lab</h1>
    <div class="subtitle">Interactive companion for “The Curious Case of Neural Text Degeneration”</div>
    <div id="serverWarning" class="status" style="margin-top:8px;color:#b91c1c;font-weight:700;"></div>
  </header>

  <div class="tabs">
    <button class="tab-btn active" data-tab="dj">Tab 1 · Decoding Lab</button>
    <button class="tab-btn" data-tab="arena">Tab 2 · Human Judge</button>
    <button class="tab-btn" data-tab="tail">Tab 3 · Distribution Explorer</button>
  </div>

  <main>
    <section id="dj" class="panel active">
      <div class="grid">
        <div class="controls stack">
          <div class="control-header">
            <span>Model & Sampling Controls</span>
            <span>Shared Sliders, Per-Sample Strategy</span>
          </div>
          <div>
            <label for="model">Model ID (local Hugging Face model)</label>
            <input id="model" type="text" value="gpt2-large" />
          </div>
          <button id="testConn">Test Local Backend</button>
          <div id="connStatus" class="status"></div>
          <div>
            <label for="prompt">Prompt</label>
            <textarea id="prompt">In a city where every billboard can write back, a teenager discovers</textarea>
          </div>
          <div>
            <label for="promptPreset">Prompt Presets (for cleaner live demos)</label>
            <select id="promptPreset">
              <option value="">Keep custom prompt</option>
              <option value="The report found that when language models are decoded greedily, they often">Paper-style analysis</option>
              <option value="Breaking news: researchers announced that the new text generator can">News style</option>
              <option value="Interviewer: What is nucleus sampling?\nResearcher:">Dialogue style</option>
              <option value="In a city where every billboard can write back, a teenager discovers">Creative fiction</option>
            </select>
          </div>
          <div>
            <label for="strategyA">Sample A Strategy</label>
            <select id="strategyA">
              <option value="greedy">Greedy</option>
              <option value="beam">Beam-ish (low temp)</option>
              <option value="topk">Top-k</option>
              <option value="topp" selected>Top-p (nucleus)</option>
            </select>
          </div>
          <div>
            <label for="strategyB">Sample B Strategy</label>
            <select id="strategyB">
              <option value="greedy">Greedy</option>
              <option value="beam">Beam-ish (low temp)</option>
              <option value="topk">Top-k</option>
              <option value="topp" selected>Top-p (nucleus)</option>
            </select>
          </div>
          <div class="legend">
            Sliders below are shared by both samples and applied based on the selected strategy.
          </div>
          <div>
            <label for="temperature">Temperature: <span id="tempVal">1.1</span></label>
            <input id="temperature" type="range" min="0.3" max="1.6" step="0.1" value="1.1" />
          </div>
          <div>
            <label for="topk">Top-k: <span id="topkVal">30</span></label>
            <input id="topk" type="range" min="5" max="80" step="1" value="30" />
          </div>
          <div>
            <label for="topp">Top-p: <span id="toppVal">0.92</span></label>
            <input id="topp" type="range" min="0.5" max="0.98" step="0.01" value="0.92" />
          </div>
          <div>
            <label for="maxTokens">Max New Tokens: <span id="maxTokensVal">120</span></label>
            <input id="maxTokens" type="range" min="20" max="300" step="10" value="120" />
          </div>
          <div>
            <label for="degenPreset">Paper Preset (degen-inspired)</label>
            <select id="degenPreset">
              <option value="">Keep custom params</option>
              <option value="greedy">Greedy (degeneration-prone)</option>
              <option value="beam">Beam-ish low-temp</option>
              <option value="topk40">Top-k 40</option>
              <option value="topp90">Top-p 0.90</option>
            </select>
          </div>
          <div>
            <label style="display:flex;align-items:center;gap:8px;margin:0;">
              <input id="streamMode" type="checkbox" checked />
              Stream Output (live token-by-token)
            </label>
          </div>
          <button id="generate" class="primary">Generate Samples</button>
          <div id="genStatus" class="status"></div>
        </div>
        <div class="stack">
          <div class="output-grid">
            <div class="card">
              <strong id="sampleALabel">Sample A</strong>
              <div id="sampleA" class="mono"></div>
              <div id="metricsA" class="metrics"></div>
            </div>
            <div class="card">
              <strong id="sampleBLabel">Sample B</strong>
              <div id="sampleB" class="mono"></div>
              <div id="metricsB" class="metrics"></div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <section id="arena" class="panel">
      <div class="card">
        <strong>Which sample sounds more human?</strong>
        <div class="legend">Click either option to reveal which sampling methods were used for left and right.</div>
        <div class="arena">
          <button id="pickLeft">
            <h4>Option Left</h4>
            <div id="leftText" class="mono"></div>
          </button>
          <button id="pickRight">
            <h4>Option Right</h4>
            <div id="rightText" class="mono"></div>
          </button>
        </div>
        <div class="score">
          Round: <span id="roundNum">1</span>/5 |
          Score: <span id="scoreNum">0</span>
          <span id="roundResult" class="result"></span>
        </div>
        <div class="stack" style="margin-top:10px;">
          <button id="genRound" class="primary">Generate Round Options</button>
          <div id="arenaStatus" class="status"></div>
          <div id="revealBox" class="legend"></div>
          <button id="nextRound">Next Round</button>
        </div>
      </div>
    </section>

    <section id="tail" class="panel">
      <div class="chart-wrap">
        <div class="chart-surface">
          <div id="tailChart" style="width:100%;height:360px;"></div>
        </div>
        <div class="controls stack">
          <div>
            <label for="distPrompt">Context Prompt (next-token distribution)</label>
            <textarea id="distPrompt">The report found that when language models are decoded greedily, they often</textarea>
          </div>
          <div>
            <label for="distN">Top candidates to request: <span id="distNVal">40</span></label>
            <input id="distN" type="range" min="10" max="100" step="5" value="40" />
          </div>
          <div>
            <label for="kCut">Top-k overlay: <span id="kCutVal">20</span></label>
            <input id="kCut" type="range" min="5" max="100" step="1" value="20" />
          </div>
          <div>
            <label for="pCut">Top-p overlay: <span id="pCutVal">0.90</span></label>
            <input id="pCut" type="range" min="0.5" max="0.98" step="0.01" value="0.9" />
          </div>
          <button id="fetchDist" class="primary">Refresh Distribution</button>
          <div id="distStatus" class="status"></div>
          <div class="kpi">Nucleus length on shown candidates: <strong id="nucleusLen">0</strong> tokens</div>
          <div class="kpi">Top-k fixed length: <strong id="topkLen">20</strong> tokens</div>
          <div class="kpi">Entropy (shown distribution): <strong id="entropyBits">0.00</strong> bits</div>
          <div class="legend">This tab uses exact next-token probabilities from local model logits.</div>
        </div>
      </div>
    </section>
  </main>

  <script>
    const tabButtons = [...document.querySelectorAll(".tab-btn")];
    const panels = [...document.querySelectorAll(".panel")];
    tabButtons.forEach((btn) => {
      btn.addEventListener("click", () => {
        tabButtons.forEach((b) => b.classList.remove("active"));
        panels.forEach((p) => p.classList.remove("active"));
        btn.classList.add("active");
        document.getElementById(btn.dataset.tab).classList.add("active");
        if (btn.dataset.tab === "tail") {
          fetchRealDistribution();
        }
      });
    });

    function apiConfig() {
      return {
        model: document.getElementById("model").value.trim() || "gpt2-large"
      };
    }

    function strategyLabel(v) {
      if (v === "greedy") return "Greedy";
      if (v === "beam") return "Beam-ish";
      if (v === "topk") return "Top-k";
      return "Top-p (nucleus)";
    }

    function mergePromptCompletion(prompt, completion) {
      const p = (prompt || "").trim();
      const c = (completion || "").trim();
      if (!p) return c;
      if (!c) return p;
      if (c.toLowerCase().startsWith(p.toLowerCase())) return c;
      return `${p} ${c}`.trim();
    }

    async function localChat({ prompt, strategy, temperature, k, p, maxTokens = 120 }) {
      const cfg = apiConfig();
      const body = { model: cfg.model, prompt, max_tokens: maxTokens };

      if (strategy === "greedy") {
        body.temperature = 0;
        body.top_p = 1;
      } else if (strategy === "beam") {
        body.temperature = 0.2;
        body.top_p = 0.35;
      } else if (strategy === "topk") {
        body.temperature = temperature;
        body.top_p = 1;
        body.top_k = k;
      } else {
        body.temperature = temperature;
        body.top_p = p;
      }

      const res = await fetch("/api/local/completions", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body)
      });
      if (!res.ok) {
        const txt = await res.text();
        throw new Error(`HTTP ${res.status}: ${txt.slice(0, 220)}`);
      }
      const data = await res.json();
      const text = data?.choices?.[0]?.text?.trim();
      if (!text) throw new Error("No output returned from model.");
      return {
        fullText: mergePromptCompletion(prompt, text),
        completionText: text,
        usage: data?.usage || null,
        performance: data?.performance || null
      };
    }

    async function localDistribution({ prompt, topN }) {
      const res = await fetch("/api/local/next-token-distribution", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          model: apiConfig().model,
          prompt,
          top_n: topN
        })
      });
      if (!res.ok) {
        const txt = await res.text();
        if (res.status === 404) {
          throw new Error("API route not found. Start with `conda run -n presentation python3 server.py`.");
        }
        throw new Error(`HTTP ${res.status}: ${txt.slice(0, 220)}`);
      }
      const data = await res.json();
      if (!Array.isArray(data?.tokens) || data.tokens.length === 0) {
        throw new Error("No token probabilities returned.");
      }
      return data;
    }

    async function localChatStream(
      { prompt, strategy, temperature, k, p, maxTokens = 120 },
      onDelta,
      onStatus
    ) {
      const cfg = apiConfig();
      const body = { model: cfg.model, prompt, max_tokens: maxTokens };
      if (strategy === "greedy") {
        body.temperature = 0;
        body.top_p = 1;
      } else if (strategy === "beam") {
        body.temperature = 0.2;
        body.top_p = 0.35;
      } else if (strategy === "topk") {
        body.temperature = temperature;
        body.top_p = 1;
        body.top_k = k;
      } else {
        body.temperature = temperature;
        body.top_p = p;
      }

      const res = await fetch("/api/local/completions_stream", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body),
      });
      if (!res.ok) {
        const txt = await res.text();
        throw new Error(`HTTP ${res.status}: ${txt.slice(0, 220)}`);
      }
      if (!res.body) throw new Error("Streaming response body unavailable.");

      const reader = res.body.getReader();
      const decoder = new TextDecoder();
      let buffer = "";
      let completion = "";
      let usage = null;
      let performance = null;
      let sawDone = false;

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        buffer += decoder.decode(value, { stream: true });
        while (true) {
          const splitAt = buffer.indexOf("\n\n");
          if (splitAt === -1) break;
          const packet = buffer.slice(0, splitAt);
          buffer = buffer.slice(splitAt + 2);
          const lines = packet.split("\n");
          for (const line of lines) {
            if (!line.startsWith("data: ")) continue;
            const payload = JSON.parse(line.slice(6));
            if (payload.type === "delta") {
              completion += payload.text || "";
              if (onDelta) onDelta(completion);
            } else if (payload.type === "status") {
              if (onStatus) onStatus(payload);
            } else if (payload.type === "done") {
              usage = payload.usage || null;
              performance = payload.performance || null;
              sawDone = true;
            } else if (payload.type === "error") {
              throw new Error(payload.error || "Streaming generation failed.");
            }
          }
        }
        if (sawDone) {
          try {
            await reader.cancel();
          } catch (_) {}
          return {
            fullText: mergePromptCompletion(prompt, completion),
            completionText: completion,
            usage,
            performance
          };
        }
      }
      return {
        fullText: mergePromptCompletion(prompt, completion),
        completionText: completion,
        usage,
        performance
      };
    }

    function distinctN(words, n) {
      if (words.length < n) return 0;
      const set = new Set();
      for (let i = 0; i <= words.length - n; i++) {
        set.add(words.slice(i, i + n).join("|"));
      }
      return set.size / (words.length - n + 1);
    }

    function repetitionRate(words) {
      const counts = new Map();
      words.forEach((w) => counts.set(w, (counts.get(w) || 0) + 1));
      let repeated = 0;
      counts.forEach((v) => { if (v > 1) repeated += v; });
      return words.length ? repeated / words.length : 0;
    }

    function metricPills(el, text, perf = null, usage = null) {
      const words = text.toLowerCase().replace(/[^\w\s]/g, "").split(/\s+/).filter(Boolean);
      const d1 = distinctN(words, 1);
      const d2 = distinctN(words, 2);
      const rep = repetitionRate(words);
      const extra = [];
      if (perf?.elapsed_ms != null) {
        extra.push(`Time ${(perf.elapsed_ms / 1000).toFixed(2)}s`);
      }
      if (perf?.tokens_per_second != null) {
        extra.push(`Tok/s ${Number(perf.tokens_per_second).toFixed(1)}`);
      }
      if (usage?.completion_tokens != null) {
        extra.push(`Gen toks ${usage.completion_tokens}`);
      }
      el.innerHTML = [
        `Distinct-1 ${d1.toFixed(2)}`,
        `Distinct-2 ${d2.toFixed(2)}`,
        `Rep ${rep.toFixed(2)}`,
        `Words ${words.length}`,
        ...extra
      ].map((x) => `<span class="metric">${x}</span>`).join("");
    }

    const promptEl = document.getElementById("prompt");
    const promptPresetEl = document.getElementById("promptPreset");
    const strategyAEl = document.getElementById("strategyA");
    const strategyBEl = document.getElementById("strategyB");
    const tempEl = document.getElementById("temperature");
    const topkEl = document.getElementById("topk");
    const toppEl = document.getElementById("topp");
    const maxTokensEl = document.getElementById("maxTokens");
    const degenPresetEl = document.getElementById("degenPreset");
    const streamModeEl = document.getElementById("streamMode");
    const sampleA = document.getElementById("sampleA");
    const sampleB = document.getElementById("sampleB");
    const sampleALabel = document.getElementById("sampleALabel");
    const sampleBLabel = document.getElementById("sampleBLabel");
    const metricsA = document.getElementById("metricsA");
    const metricsB = document.getElementById("metricsB");
    const connStatus = document.getElementById("connStatus");
    const genStatus = document.getElementById("genStatus");
    const generateBtn = document.getElementById("generate");
    const serverWarning = document.getElementById("serverWarning");

    function syncLabels() {
      document.getElementById("tempVal").textContent = tempEl.value;
      document.getElementById("topkVal").textContent = topkEl.value;
      document.getElementById("toppVal").textContent = Number(toppEl.value).toFixed(2);
      document.getElementById("maxTokensVal").textContent = maxTokensEl.value;
    }

    async function runGeneration() {
      const baseConfig = {
        prompt: promptEl.value.trim() || "Once upon a time",
        temperature: Number(tempEl.value),
        k: Number(topkEl.value),
        p: Number(toppEl.value),
        maxTokens: Number(maxTokensEl.value)
      };
      const configA = { ...baseConfig, strategy: strategyAEl.value };
      const configB = { ...baseConfig, strategy: strategyBEl.value };
      sampleALabel.textContent = `Sample A - ${strategyLabel(configA.strategy)}`;
      sampleBLabel.textContent = `Sample B - ${strategyLabel(configB.strategy)}`;
      sampleA.textContent = "Generating...";
      sampleB.textContent = "Generating...";
      metricsA.innerHTML = "";
      metricsB.innerHTML = "";
      genStatus.textContent = "Generating with local transformers...";
      generateBtn.disabled = true;
      try {
        let a;
        let b;
        if (streamModeEl.checked) {
          genStatus.textContent = "Streaming Sample A...";
          sampleA.textContent = baseConfig.prompt;
          a = await localChatStream(
            configA,
            (partial) => {
              sampleA.textContent = mergePromptCompletion(baseConfig.prompt, partial);
            },
            (status) => {
              if (status?.message === "loading_runtime") {
                genStatus.textContent = "Loading model/runtime for streaming...";
              } else if (status?.message === "runtime_ready") {
                genStatus.textContent = `Streaming Sample A... (${status.device})`;
              }
            }
          );
          metricPills(metricsA, a.fullText, a.performance, a.usage);

          genStatus.textContent = "Streaming Sample B...";
          sampleB.textContent = baseConfig.prompt;
          b = await localChatStream(configB, (partial) => {
            sampleB.textContent = mergePromptCompletion(baseConfig.prompt, partial);
          });
          metricPills(metricsB, b.fullText, b.performance, b.usage);
        } else {
          [a, b] = await Promise.all([
            localChat(configA),
            localChat(configB)
          ]);
          sampleA.textContent = a.fullText;
          sampleB.textContent = b.fullText;
          metricPills(metricsA, a.fullText, a.performance, a.usage);
          metricPills(metricsB, b.fullText, b.performance, b.usage);
        }
        sampleA.textContent = a.fullText;
        sampleB.textContent = b.fullText;
        genStatus.textContent = "Done.";
      } catch (err) {
        sampleA.textContent = "Generation failed.";
        sampleB.textContent = "Generation failed.";
        genStatus.textContent = `Error: ${err.message}`;
      } finally {
        generateBtn.disabled = false;
      }
    }

    [tempEl, topkEl, toppEl, maxTokensEl].forEach((el) => el.addEventListener("input", syncLabels));
    degenPresetEl.addEventListener("change", () => {
      const v = degenPresetEl.value;
      if (!v) return;
      if (v === "greedy") {
        strategyAEl.value = "greedy";
        strategyBEl.value = "greedy";
        tempEl.value = "0.3";
        toppEl.value = "0.98";
      } else if (v === "beam") {
        strategyAEl.value = "beam";
        strategyBEl.value = "beam";
        tempEl.value = "0.2";
        toppEl.value = "0.35";
      } else if (v === "topk40") {
        strategyAEl.value = "topk";
        strategyBEl.value = "topk";
        topkEl.value = "40";
        tempEl.value = "1.0";
        toppEl.value = "0.98";
      } else if (v === "topp90") {
        strategyAEl.value = "topp";
        strategyBEl.value = "topp";
        toppEl.value = "0.90";
        tempEl.value = "1.0";
      }
      syncLabels();
    });
    promptPresetEl.addEventListener("change", () => {
      if (promptPresetEl.value) promptEl.value = promptPresetEl.value;
    });
    generateBtn.addEventListener("click", () => { runGeneration(); });
    document.getElementById("testConn").addEventListener("click", async () => {
      connStatus.textContent = "Testing...";
      try {
        const cfg = apiConfig();
        const res = await fetch("/api/local/health", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ model: cfg.model, preload: true })
        });
        if (!res.ok) throw new Error(await res.text());
        const payload = await res.json();
        connStatus.textContent = `Ready on ${payload.device || "cpu"} (loaded in ${payload.loaded_in_s || "?"}s).`;
      } catch (err) {
        connStatus.textContent = `Connection failed: ${err.message}`;
      }
    });
    syncLabels();
    genStatus.textContent = "Ready.";

    async function checkApiServer() {
      try {
        const res = await fetch("/api/local/health", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ model: apiConfig().model })
        });
        if (res.status === 404) {
          serverWarning.textContent = "Wrong server: run `conda run -n presentation python3 server.py`.";
          return;
        }
        serverWarning.textContent = "";
      } catch (_) {
        serverWarning.textContent = "";
      }
    }
    checkApiServer();

    const arenaData = [
      "At midnight the chatbot started writing poetry on receipts.",
      "A satellite with a sense of humor sent one final message:",
      "The town replaced streetlights with tiny language models.",
      "When the museum digitized every diary,",
      "The AI weather report stopped predicting rain and started predicting moods."
    ];

    let round = 0;
    let score = 0;
    let leftIsGood = true;
    let leftMethod = "";
    let rightMethod = "";
    const leftText = document.getElementById("leftText");
    const rightText = document.getElementById("rightText");
    const roundNum = document.getElementById("roundNum");
    const scoreNum = document.getElementById("scoreNum");
    const roundResult = document.getElementById("roundResult");
    const revealBox = document.getElementById("revealBox");
    const arenaStatus = document.getElementById("arenaStatus");
    const genRoundBtn = document.getElementById("genRound");
    let currentPrompt = "";

    async function loadRound() {
      currentPrompt = arenaData[round];
      leftIsGood = Math.random() > 0.5;
      leftText.textContent = "Generating option...";
      rightText.textContent = "Generating option...";
      roundNum.textContent = String(round + 1);
      scoreNum.textContent = String(score);
      roundResult.textContent = "";
      roundResult.className = "result";
      revealBox.textContent = "";
      arenaStatus.textContent = `Generating round ${round + 1} options locally...`;
      genRoundBtn.disabled = true;
      try {
        arenaStatus.textContent = `Streaming round ${round + 1} options...`;
        const good = await localChatStream(
          {
            prompt: currentPrompt,
            strategy: "topp",
            temperature: Math.max(Number(tempEl.value), 0.7),
            k: Number(topkEl.value),
            p: Math.max(Number(toppEl.value), 0.9),
            maxTokens: Math.min(Number(maxTokensEl.value), 120)
          },
          (partial) => {
            const txt = `${currentPrompt} ${partial}`.trim();
            if (leftIsGood) leftText.textContent = txt;
            else rightText.textContent = txt;
          }
        );
        const bad = await localChatStream(
          {
            prompt: currentPrompt,
            strategy: "greedy",
            temperature: Number(tempEl.value),
            k: Number(topkEl.value),
            p: Number(toppEl.value),
            maxTokens: Math.min(Number(maxTokensEl.value), 120)
          },
          (partial) => {
            const txt = `${currentPrompt} ${partial}`.trim();
            if (leftIsGood) rightText.textContent = txt;
            else leftText.textContent = txt;
          }
        );
        leftText.textContent = leftIsGood ? good.fullText : bad.fullText;
        rightText.textContent = leftIsGood ? bad.fullText : good.fullText;
        leftMethod = leftIsGood ? "Top-p (nucleus)" : "Greedy";
        rightMethod = leftIsGood ? "Greedy" : "Top-p (nucleus)";
        arenaStatus.textContent = "Round ready. Ask the audience to vote.";
      } catch (err) {
        leftText.textContent = "Generation failed.";
        rightText.textContent = "Generation failed.";
        arenaStatus.textContent = `Round generation failed: ${err.message}`;
      } finally {
        genRoundBtn.disabled = false;
      }
    }

    function evaluatePick(pickedLeft) {
      const correct = pickedLeft === leftIsGood;
      if (correct) score++;
      scoreNum.textContent = String(score);
      roundResult.textContent = correct ? "  Correct pick." : "  Not this one.";
      roundResult.className = `result ${correct ? "ok" : "bad"}`;
      revealBox.innerHTML = `Left: <strong>${leftMethod}</strong> | Right: <strong>${rightMethod}</strong>`;
    }

    document.getElementById("pickLeft").addEventListener("click", () => evaluatePick(true));
    document.getElementById("pickRight").addEventListener("click", () => evaluatePick(false));
    genRoundBtn.addEventListener("click", () => { loadRound(); });
    document.getElementById("nextRound").addEventListener("click", () => {
      round = (round + 1) % arenaData.length;
      loadRound();
    });
    arenaStatus.textContent = "Ready.";

    const tailChartEl = document.getElementById("tailChart");
    const distPromptEl = document.getElementById("distPrompt");
    const distNEl = document.getElementById("distN");
    const fetchDistBtn = document.getElementById("fetchDist");
    const distStatus = document.getElementById("distStatus");
    const kCutEl = document.getElementById("kCut");
    const pCutEl = document.getElementById("pCut");
    const distNVal = document.getElementById("distNVal");
    const kCutVal = document.getElementById("kCutVal");
    const pCutVal = document.getElementById("pCutVal");
    const nucleusLen = document.getElementById("nucleusLen");
    const topkLen = document.getElementById("topkLen");
    const entropyBits = document.getElementById("entropyBits");

    let distTokens = [];
    function tokenLabel(token) {
      return token
        .replace(/\n/g, "\\n")
        .replace(/\t/g, "\\t")
        .replace(/ /g, "·");
    }

    function drawTailChart() {
      if (typeof Plotly === "undefined") {
        distStatus.textContent = "Plotly failed to load. Check internet access, then refresh.";
        return;
      }
      const probs = distTokens.map((t) => t.prob);
      const kRaw = Number(kCutEl.value);
      const p = Number(pCutEl.value);
      if (!probs.length) {
        Plotly.react(tailChartEl, [], {
          margin: { l: 64, r: 24, t: 20, b: 60 },
          xaxis: { title: "Token Rank" },
          yaxis: { title: "Probability (%)", rangemode: "tozero" },
          annotations: [{
            x: 0.5, y: 0.5, xref: "paper", yref: "paper",
            text: "No distribution loaded yet.",
            showarrow: false, font: { size: 16, color: "#4d5b70" }
          }],
          paper_bgcolor: "#ffffff",
          plot_bgcolor: "#fbfdff"
        }, { displayModeBar: false, responsive: true });
        nucleusLen.textContent = "0";
        topkLen.textContent = String(kRaw);
        entropyBits.textContent = "0.00";
        return;
      }
      const k = Math.min(kRaw, probs.length);

      const shownMass = probs.reduce((a, b) => a + b, 0);
      const renorm = shownMass > 0 ? probs.map((x) => x / shownMass) : probs;
      let cum = 0;
      let pLen = 0;
      for (let i = 0; i < renorm.length; i++) {
        cum += renorm[i];
        if (cum >= p) { pLen = i + 1; break; }
      }
      let cumLocal = 0;
      const xVals = [];
      const yVals = [];
      const colors = [];
      const hover = [];
      for (let i = 0; i < probs.length; i++) {
        xVals.push(i + 1);
        yVals.push(probs[i] * 100);
        const inTopK = i < k;
        const inTopP = i < pLen;
        cumLocal += renorm[i];
        if (inTopP) colors.push("#0f766ecc");
        else if (inTopK) colors.push("#b45309aa");
        else colors.push("#b91c1c44");
        hover.push([
          `Token: ${tokenLabel(distTokens[i].token)}`,
          `Rank: ${i + 1}`,
          `Prob: ${(probs[i] * 100).toFixed(3)}%`,
          `Cumulative: ${(cumLocal * 100).toFixed(2)}%`,
          `In Top-k: ${inTopK ? "yes" : "no"}`,
          `In Top-p: ${inTopP ? "yes" : "no"}`
        ].join("<br>"));
      }
      const tickStep = Math.max(1, Math.ceil(xVals.length / 20));
      const tickVals = [];
      const tickText = [];
      for (let i = 0; i < xVals.length; i += tickStep) {
        tickVals.push(i + 1);
        tickText.push(tokenLabel(distTokens[i].token));
      }
      Plotly.react(
        tailChartEl,
        [{
          type: "bar",
          x: xVals,
          y: yVals,
          marker: { color: colors, line: { width: 0 } },
          hovertemplate: "%{customdata}<extra></extra>",
          customdata: hover
        }],
        {
          margin: { l: 72, r: 24, t: 24, b: 88 },
          paper_bgcolor: "#ffffff",
          plot_bgcolor: "#fbfdff",
          xaxis: {
            title: "Token Rank (Hover bars for labels)",
            tickmode: "array",
            tickvals: tickVals,
            ticktext: tickText,
            tickangle: -25
          },
          yaxis: { title: "Probability (%)", rangemode: "tozero" },
          shapes: [
            {
              type: "line",
              x0: k + 0.5, x1: k + 0.5, y0: 0, y1: Math.max(...yVals) * 1.05,
              line: { color: "#b45309", dash: "dash", width: 2 }
            },
            {
              type: "line",
              x0: pLen + 0.5, x1: pLen + 0.5, y0: 0, y1: Math.max(...yVals) * 1.05,
              line: { color: "#0f766e", dash: "dot", width: 2 }
            }
          ],
          annotations: [
            { x: k + 0.5, y: Math.max(...yVals) * 1.07, text: "Top-k cut", showarrow: false, font: { size: 11, color: "#8a4b00" } },
            { x: pLen + 0.5, y: Math.max(...yVals) * 1.13, text: "Top-p cut", showarrow: false, font: { size: 11, color: "#0f766e" } }
          ],
          hoverlabel: { bgcolor: "#0f172a", font: { color: "#eef4ff", size: 12 } }
        },
        { displayModeBar: true, responsive: true }
      );

      const entropy = renorm.reduce((acc, pr) => (pr > 0 ? acc - pr * Math.log2(pr) : acc), 0);
      distNVal.textContent = String(Number(distNEl.value));
      kCutVal.textContent = String(kRaw);
      pCutVal.textContent = Number(p).toFixed(2);
      nucleusLen.textContent = String(pLen);
      topkLen.textContent = String(k);
      entropyBits.textContent = entropy.toFixed(2);
    }

    async function fetchRealDistribution() {
      distStatus.textContent = "Fetching exact next-token probabilities from local model...";
      fetchDistBtn.disabled = true;
      try {
        distTokens = await localDistribution({
          prompt: distPromptEl.value.trim() || "The report found that",
          topN: Number(distNEl.value)
        });
        const modeText = distTokens.mode === "exact_logits"
          ? "exact logits"
          : "distribution fallback";
        distTokens = distTokens.tokens;
        distStatus.textContent = `Distribution loaded using ${modeText}. Hover bars for details.`;
        drawTailChart();
      } catch (err) {
        distStatus.textContent = `Failed: ${err.message}`;
      } finally {
        fetchDistBtn.disabled = false;
      }
    }

    fetchDistBtn.addEventListener("click", () => { fetchRealDistribution(); });
    [kCutEl, pCutEl].forEach((el) => el.addEventListener("input", drawTailChart));
    distNEl.addEventListener("input", () => {
      distNVal.textContent = String(Number(distNEl.value));
    });
    promptPresetEl.addEventListener("change", () => {
      if (promptPresetEl.value) distPromptEl.value = promptPresetEl.value;
    });
    window.addEventListener("resize", drawTailChart);
    drawTailChart();
    distStatus.textContent = "Ready.";
  </script>
</body>
</html>

<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Neural Text Degeneration Explorer</title>
  <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
  <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;700&family=Fraunces:opsz,wght@9..144,500;9..144,700&display=swap');

    :root {
      --bg-0: #eff8f3;
      --bg-1: #e1f0e7;
      --bg-2: #eef7f1;
      --surface: #ffffff;
      --surface-soft: #f6fbf8;
      --ink: #172133;
      --muted: #5d697d;
      --line: #c7dfd0;
      --brand: #24784f;
      --brand-2: #2f8d60;
      --accent: #3e8f66;
      --danger: #b42318;
      --ok: #136c44;
      --shadow-lg: 0 18px 32px rgba(21, 38, 62, 0.12);
      --shadow-sm: 0 8px 16px rgba(18, 34, 53, 0.08);
      --radius-xl: 18px;
      --radius-md: 12px;
      --paper-bg: #ffffff;
      --plot-bg: #f4fbf7;
      --plot-grid: #d5e6dc;
      --topk-line: #3e8f66;
      --topp-line: #1e6b49;
      --bar-topp: rgba(47, 141, 96, 0.85);
      --bar-topk: rgba(62, 143, 102, 0.70);
      --bar-tail: rgba(180, 35, 24, 0.28);
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      color: var(--ink);
      font-family: "Space Grotesk", "Segoe UI", sans-serif;
      background:
        radial-gradient(1200px 700px at 110% -10%, #d7f0e2 0%, transparent 75%),
        radial-gradient(1000px 520px at -8% 108%, #d9efe2 0%, transparent 70%),
        linear-gradient(150deg, var(--bg-0), var(--bg-1));
    }

    .app {
      max-width: 1320px;
      margin: 0 auto;
      padding: 18px 18px 28px;
      display: grid;
      gap: 14px;
    }

    .hero {
      position: relative;
      overflow: hidden;
      border: 1px solid var(--line);
      border-radius: var(--radius-xl);
      background:
        linear-gradient(110deg, #ffffff 0%, #f4fbf7 58%, #ebf7f1 100%);
      box-shadow: var(--shadow-lg);
      padding: 18px;
      display: grid;
      gap: 12px;
    }

    .hero::before {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(90deg, transparent, rgba(47, 141, 96, 0.08), transparent);
      transform: translateX(-100%);
      animation: heroSweep 7s ease-in-out infinite;
      pointer-events: none;
    }

    @keyframes heroSweep {
      0%, 25% { transform: translateX(-100%); }
      55%, 100% { transform: translateX(100%); }
    }

    .hero::after {
      content: "";
      position: absolute;
      width: 420px;
      height: 420px;
      border-radius: 50%;
      background: radial-gradient(circle at center, rgba(36, 120, 79, 0.16), transparent 68%);
      right: -130px;
      top: -190px;
      pointer-events: none;
    }

    .hero-title {
      margin: 0;
      font-family: "Fraunces", "Times New Roman", serif;
      font-size: clamp(1.4rem, 2.8vw, 2.5rem);
      letter-spacing: 0.01em;
    }

    .hero-subtitle {
      margin: 0;
      font-size: 0.95rem;
      color: var(--muted);
    }

    .hero-note {
      margin: 0;
      padding: 8px 10px;
      border: 1px dashed var(--line);
      border-radius: 10px;
      font-size: 0.84rem;
      color: var(--muted);
      background: rgba(255, 255, 255, 0.55);
      max-width: 760px;
    }

    .hero-row {
      display: grid;
      grid-template-columns: auto auto;
      gap: 10px;
      align-items: end;
      justify-content: start;
    }

    .model-compact {
      min-width: 250px;
      max-width: 280px;
    }

    .model-compact select {
      font-size: 0.95rem;
      padding: 8px 10px;
    }

    .theme-topright {
      position: absolute;
      top: 16px;
      right: 16px;
      width: 180px;
      z-index: 3;
    }

    body[data-theme="ocean"] {
      --bg-0: #eef6fb;
      --bg-1: #dfedf8;
      --bg-2: #e8f2fa;
      --surface: #ffffff;
      --surface-soft: #f6fbff;
      --ink: #152238;
      --muted: #516683;
      --line: #c8d9eb;
      --brand: #2f6bcf;
      --brand-2: #2f9acf;
      --accent: #2f7dcf;
      --paper-bg: #ffffff;
      --plot-bg: #f6fbff;
      --plot-grid: #d8e6f5;
      --topk-line: #2f9acf;
      --topp-line: #2f7dcf;
      --bar-topp: rgba(47, 107, 207, 0.88);
      --bar-topk: rgba(47, 154, 207, 0.70);
      --bar-tail: rgba(180, 35, 24, 0.28);
    }

    body[data-theme="night"] {
      --bg-0: #0d151b;
      --bg-1: #0f1c26;
      --bg-2: #11202b;
      --surface: #111d27;
      --surface-soft: #152532;
      --ink: #e8f3ff;
      --muted: #9eb3c7;
      --line: #2d485a;
      --brand: #4ba97a;
      --brand-2: #6dd0a0;
      --accent: #64c497;
      --paper-bg: #111d27;
      --plot-bg: #0f1a23;
      --plot-grid: #284153;
      --topk-line: #64c497;
      --topp-line: #4ba97a;
      --bar-topp: rgba(75, 169, 122, 0.88);
      --bar-topk: rgba(100, 196, 151, 0.70);
      --bar-tail: rgba(248, 113, 113, 0.32);
      --shadow-lg: none;
      --shadow-sm: none;
    }

    .field { display: grid; gap: 6px; }

    .field label {
      font-size: 0.8rem;
      color: var(--muted);
      letter-spacing: 0.03em;
      text-transform: uppercase;
      font-weight: 700;
    }

    input[type="text"],
    textarea,
    select,
    button,
    input[type="range"] {
      width: 100%;
      color: var(--ink);
      font: inherit;
      border: 1px solid #c5d3e4;
      border-radius: 10px;
      background: #fff;
    }

    input[type="text"],
    textarea,
    select,
    button {
      padding: 10px 12px;
    }

    textarea {
      resize: vertical;
      min-height: 92px;
      line-height: 1.42;
    }

    input[type="range"] {
      accent-color: var(--brand);
      padding: 0;
      height: 30px;
      border: 0;
      background: transparent;
    }

    button {
      font-weight: 700;
      cursor: pointer;
      transition: transform 120ms ease, box-shadow 120ms ease, background 120ms ease;
      background: linear-gradient(180deg, #ffffff, #edf8f2);
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: var(--shadow-sm);
    }

    button:disabled {
      cursor: not-allowed;
      opacity: 0.62;
      transform: none;
      box-shadow: none;
    }

    .primary {
      color: #fff;
      border-color: var(--brand);
      background: linear-gradient(180deg, #359969, var(--brand));
    }

    .tabs {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 10px;
    }

    .tab-btn {
      border-radius: 12px;
      border: 1px solid var(--line);
      background: #f4fbf7;
      padding: 12px 10px;
      font-weight: 700;
      letter-spacing: 0.01em;
    }

    .tab-btn.active {
      border-color: var(--brand);
      color: #fff;
      background: linear-gradient(180deg, #359969, var(--brand));
      box-shadow: 0 12px 24px rgba(36, 120, 79, 0.24);
    }

    .panel {
      display: none;
      border: 1px solid var(--line);
      border-radius: var(--radius-xl);
      background: var(--surface);
      box-shadow: var(--shadow-lg);
      padding: 14px;
    }

    .panel.active {
      display: block;
      animation: panelFade 320ms ease;
    }

    @keyframes panelFade {
      from { opacity: 0; transform: translateY(4px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .toolbar {
      display: grid;
      grid-template-columns: auto 1fr;
      gap: 10px;
      align-items: center;
      margin-bottom: 12px;
    }

    .status {
      min-height: 1.2em;
      color: var(--muted);
      font-size: 0.86rem;
      font-weight: 500;
    }

    .status.error { color: var(--danger); }
      .status.error { color: #e53935; }
    body[data-theme="night"] input[type="text"],
    body[data-theme="night"] textarea,
    body[data-theme="night"] select,
    body[data-theme="night"] button {
      background: #10202b;
      border-color: #2d485a;
      color: var(--ink);
    }

    body[data-theme="night"] .hero {
      background: linear-gradient(110deg, #13222e 0%, #152633 58%, #162b37 100%);
    }

    body[data-theme="night"] .hero-note {
      background: rgba(17, 32, 43, 0.65);
    }

    body[data-theme="night"] .tab-btn {
      background: #11202b;
      color: var(--ink);
    }

    body[data-theme="night"] .mono,
    body[data-theme="night"] #tailChart {
      background: #0f1a23;
      border-color: #2d485a;
    }

    body[data-theme="night"] .metric,
    body[data-theme="night"] .kpi,
    body[data-theme="night"] .chip {
      background: #18303d;
      border-color: #335365;
      color: #d8f3e7;
    }

    .chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 0.8rem;
      font-weight: 700;
      border: 1px solid #d1e7da;
      background: #edf9f1;
    }

    .grid-2 {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 12px;
      align-items: start;
    }

    .card {
      border: 1px solid #d0e5d7;
      border-radius: 14px;
      background: var(--surface-soft);
      padding: 12px;
      display: grid;
      gap: 10px;
      transition: transform 160ms ease, box-shadow 160ms ease;
    }

    .card:hover {
      transform: translateY(-1px);
      box-shadow: var(--shadow-sm);
    }

    .sample-header {
      display: flex;
      justify-content: space-between;
      gap: 10px;
      align-items: center;
    }

    .sample-title {
      margin: 0;
      font-size: 1.03rem;
      letter-spacing: 0.01em;
    }

    .metric-help-wrap {
      position: relative;
      display: inline-flex;
      align-items: center;
    }

    .metric-help {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 1px solid #b8d9c6;
      background: #eef9f2;
      color: #1f4a34;
      font-size: 0.72rem;
      font-weight: 800;
      cursor: help;
      user-select: none;
      padding: 0;
      appearance: none;
      outline: none;
    }

    .metric-help-pop {
      position: absolute;
      top: calc(100% + 8px);
      left: 0;
      width: min(420px, 80vw);
      background: #0f1f19;
      color: #e9fff3;
      border-radius: 10px;
      border: 1px solid #2e5f4b;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
      padding: 8px 10px;
      font-size: 0.78rem;
      line-height: 1.35;
      z-index: 12;
      display: none;
    }

    .metric-help-wrap:hover .metric-help-pop,
    .metric-help-wrap:focus-within .metric-help-pop {
      display: block;
    }

    .param-hint {
      font-size: 0.8rem;
      color: var(--muted);
    }

    .controls {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 8px 10px;
    }

    .mono {
      border: 1px solid #d3e4d9;
      border-radius: 12px;
      background: #fff;
      padding: 12px;
      min-height: 150px;
      white-space: pre-wrap;
      line-height: 1.48;
      font-size: 0.88rem;
      font-family: ui-monospace, Menlo, Consolas, monospace;
    }

    /* Keep Tab 1 outputs stable for side-by-side comparison */
    #sampleA, #sampleB {
      height: 280px;
      min-height: 280px;
      overflow-y: auto;
    }

    .compare-card {
      grid-template-rows: auto 280px auto auto auto;
      align-content: start;
    }

    #metricsA, #metricsB {
      min-height: 36px;
      align-content: start;
    }

    #statusA, #statusB {
      min-height: 20px;
    }

    .metrics {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .metric {
      border: 1px solid #d4e8dc;
      background: #edf9f1;
      border-radius: 999px;
      padding: 5px 9px;
      font-size: 0.76rem;
      font-weight: 700;
      color: #1f4a34;
    }

    .arena-head {
      display: grid;
      gap: 10px;
    }

    .arena-score {
      font-size: 0.9rem;
      color: var(--muted);
      font-weight: 700;
    }

    .arena-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 12px;
    }

    .arena-option {
      text-align: left;
      min-height: 220px;
      display: grid;
      gap: 8px;
      font-weight: 500;
    }

    .arena-option h4 {
      margin: 0;
      font-size: 0.95rem;
      letter-spacing: 0.01em;
    }

    .arena-option .mono {
      font-weight: 400;
    }

    .arena-meta {
      font-size: 0.78rem;
      color: var(--muted);
      min-height: 1.1em;
      font-weight: 600;
    }

    .result-ok { color: var(--ok); font-weight: 800; }
    .result-bad { color: var(--danger); font-weight: 800; }
    .winner-banner {
      margin-top: 8px;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid var(--brand);
      background: rgba(36, 120, 79, 0.14);
      font-weight: 900;
      font-size: 1rem;
      letter-spacing: 0.01em;
    }

    .dist-layout {
      display: grid;
      gap: 12px;
    }

    .dist-output-grid {
      display: grid;
      grid-template-columns: 1fr 320px;
      gap: 12px;
      align-items: start;
    }

    .dist-readouts {
      align-content: start;
      gap: 10px;
    }

    .dist-controls-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px 12px;
    }

    .dist-actions {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }

    #tailChart {
      width: 100%;
      height: 430px;
      border: 1px solid #cfe2d5;
      border-radius: 14px;
      background: #fff;
    }

    #distPrompt {
      min-height: 72px;
    }

    #sharedPrompt {
      min-height: 72px;
    }

    .stack-controls {
      grid-template-columns: 1fr;
    }

    .mono.generating {
      background:
        linear-gradient(90deg, rgba(36, 120, 79, 0.08), rgba(36, 120, 79, 0.16), rgba(36, 120, 79, 0.08));
      background-size: 220% 100%;
      animation: loadingSweep 1.2s linear infinite;
    }

    @keyframes loadingSweep {
      from { background-position: 200% 0; }
      to { background-position: -200% 0; }
    }

    .kpis {
      display: grid;
      gap: 8px;
    }

    .kpi {
      border: 1px solid #d0e4d8;
      border-radius: 10px;
      padding: 8px 10px;
      font-size: 0.84rem;
      background: #edf9f1;
    }

    .server-warning {
      color: var(--danger);
      font-size: 0.84rem;
      min-height: 1.1em;
      font-weight: 700;
    }

    .site-footer {
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 12px 14px;
      background: linear-gradient(180deg, #ffffff, #edf8f2);
      color: var(--muted);
      font-size: 0.9rem;
      text-align: center;
      box-shadow: var(--shadow-sm);
    }

    .wm-grid {
      display: grid;
      grid-template-columns: 320px 1fr;
      gap: 12px;
      align-items: start;
    }

    .wm-output {
      min-height: 280px;
      max-height: 420px;
      overflow-y: auto;
    }

    .wm-compare {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .wm-col h4 {
      margin: 0 0 6px 0;
      font-size: 0.9rem;
      color: var(--muted);
      letter-spacing: 0.01em;
    }

    .wm-token {
      display: inline-block;
      margin: 2px 3px 2px 0;
      padding: 2px 5px;
      border-radius: 6px;
      border: 1px solid transparent;
      font-family: ui-monospace, Menlo, Consolas, monospace;
      font-size: 0.86rem;
      line-height: 1.5;
    }

    .wm-token.green {
      background: rgba(19, 108, 68, 0.16);
      border-color: rgba(19, 108, 68, 0.38);
      color: #145437;
    }

    .wm-token.red {
      background: rgba(180, 35, 24, 0.12);
      border-color: rgba(180, 35, 24, 0.32);
      color: #7f1d17;
    }

    .wm-legend {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      color: var(--muted);
      font-size: 0.82rem;
      font-weight: 700;
    }

    body[data-theme="night"] .site-footer {
      background: #11202b;
    }

    @media (max-width: 1120px) {
      .theme-topright {
        position: static;
        width: auto;
      }
      .hero-row { grid-template-columns: 1fr; }
      .toolbar { grid-template-columns: 1fr; }
      .grid-2,
      .arena-grid,
      .tabs,
      .controls { grid-template-columns: 1fr; }
      .dist-output-grid,
      .dist-controls-grid,
      .dist-actions,
      .wm-grid { grid-template-columns: 1fr; }
      .wm-compare { grid-template-columns: 1fr; }
      #tailChart { height: 360px; }
    }
  </style>
</head>
<body>
  <div class="app">
    <header class="hero">
      <h1 class="hero-title">Neural Text Degeneration Explorer</h1>
      <p class="hero-subtitle">Built for exploring Holtzman et al. (2019) and beyond, as a presentation dashboard for CPSC 532B.</p>
      <p class="hero-note">Project scope: interactive comparison of greedy, top-k, top-p, and beam search with live distribution analysis and blind preference rounds.</p>
      <div class="field theme-topright">
        <label for="themeSelect">Theme</label>
        <select id="themeSelect">
          <option value="forest" selected>Forest</option>
          <option value="ocean">Ocean</option>
          <option value="night">Night</option>
        </select>
      </div>
      <div class="hero-row">
        <div class="field model-compact">
          <label for="model">Model</label>
          <select id="model">
            <option value="gpt2-large" selected>gpt2-large</option>
            <option value="gpt2-xl">gpt2-xl</option>
            <option value="gpt2-medium">gpt2-medium</option>
            <option value="Qwen/Qwen3-0.6B">Qwen3-0.6B</option>
            <option value="Qwen/Qwen2.5-0.5B">Qwen2.5-0.5B</option>
          </select>
        </div>
        <button id="preloadModel">Load Model</button>
      </div>
      <div id="connStatus" class="status"></div>
      <div id="serverWarning" class="server-warning"></div>
    </header>

    <nav class="tabs">
      <button class="tab-btn active" data-tab="tab3">Distribution Explorer</button>
      <button class="tab-btn" data-tab="tab1">Side-by-Side Decode</button>
      <button class="tab-btn" data-tab="tab2">Human Preference Arena</button>
      <button class="tab-btn" data-tab="tab4">KGW Watermark (Bonus)</button>
    </nav>

    <section id="tab1" class="panel">
      <div class="card" style="margin-bottom:12px;">
        <div class="controls stack-controls">
          <div class="field">
            <label for="promptTemplate">Prompt Template</label>
            <select id="promptTemplate">
              <option value="paper_unicorn">Paper · In a shocking finding, scientists discovered</option>
              <option value="paper_university">Paper · The university said in a statement that</option>
              <option value="paper_city">Paper · The city council announced that</option>
              <option value="paper_museum">Paper · The museum curator explained that</option>
              <option value="paper_story">Paper · Once upon a time, in a small village</option>
              <option value="paper_essay">Paper · The meaning of life is</option>
              <option value="paper_news">Paper · The report found that</option>
              <option value="paper_fig5_flat">Paper Fig 5 · She said, \" I never</option>
              <option value="paper_fig5_peaked">Paper Fig 5 · I ate the pizza while it was still</option>
              <option value="paper_appendix_life">Paper Appendix · So what's new in my life?</option>
              <option value="paper_appendix_vacation">Paper Appendix · Just got back from vacation.</option>
              <option value="paper_appendix_wallpaper">Paper Appendix · How can I change the background wallpaper</option>
              <option value="city_billboard">Reactive city billboard story</option>
              <option value="receipt_poetry">Receipt poetry at midnight</option>
              <option value="satellite_last">Satellite final message</option>
              <option value="museum_diary">Museum digitized diaries</option>
              <option value="weather_mood">Weather report predicts moods</option>
            </select>
          </div>
          <div class="field">
            <label for="sharedPrompt">Shared Prompt (used by A and B)</label>
            <textarea id="sharedPrompt">In a city where every billboard can write back, a teenager discovers</textarea>
          </div>
        </div>
      </div>

      <div class="toolbar">
        <button id="generateBoth" class="primary">Generate Both Samples</button>
        <span class="metric-help-wrap">
          <button class="metric-help" type="button" aria-label="Metric definitions">?</button>
          <span class="metric-help-pop">
            Zipf coef: slope-based lexical concentration estimate. Rep-2/3/4: repeated n-gram rates
            (higher means more repetition). Words: total word count. Tok/s: completion tokens per second.
            Generated: completion token count.
          </span>
        </span>
        <div id="genStatus" class="status"></div>
      </div>

      <div class="grid-2">
        <article class="card compare-card">
          <div class="sample-header">
            <h3 id="sampleATitle" class="sample-title">Sample A · Top-p</h3>
            <button id="generateA">Generate A</button>
          </div>

          <div id="sampleA" class="mono"></div>
          <div id="metricsA" class="metrics"></div>
          <div id="statusA" class="status"></div>

          <div class="controls">
            <div class="field">
              <label for="aStrategy">Decoding Strategy</label>
              <select id="aStrategy">
                <option value="greedy">Greedy</option>
                <option value="beam">Beam Search</option>
                <option value="topk">Top-k</option>
                <option value="topp" selected>Top-p (Nucleus)</option>
                <option value="sample">Pure Sampling</option>
              </select>
            </div>

            <div class="field">
              <label for="aMaxTokens">Max Tokens: <span id="aMaxTokensVal">100</span></label>
              <input id="aMaxTokens" type="range" min="20" max="200" step="10" value="100" />
            </div>

            <div id="aTempWrap" class="field">
              <label for="aTemp">Temperature: <span id="aTempVal">1.00</span></label>
              <input id="aTemp" type="range" min="0" max="2.0" step="0.05" value="1.00" />
            </div>

            <div id="aTopkWrap" class="field">
              <label for="aTopk">Top-k: <span id="aTopkVal">40</span></label>
              <input id="aTopk" type="range" min="1" max="320" step="1" value="40" />
            </div>

            <div id="aToppWrap" class="field">
              <label for="aTopp">Top-p: <span id="aToppVal">0.95</span></label>
              <input id="aTopp" type="range" min="0.10" max="1.00" step="0.01" value="0.95" />
            </div>

            <div id="aBeamWrap" class="field">
              <label for="aBeam">Beam Size (b): <span id="aBeamVal">4</span></label>
              <input id="aBeam" type="range" min="1" max="16" step="1" value="4" />
            </div>

          </div>
        </article>

        <article class="card compare-card">
          <div class="sample-header">
            <h3 id="sampleBTitle" class="sample-title">Sample B · Greedy</h3>
            <button id="generateB">Generate B</button>
          </div>

          <div id="sampleB" class="mono"></div>
          <div id="metricsB" class="metrics"></div>
          <div id="statusB" class="status"></div>

          <div class="controls">
            <div class="field">
              <label for="bStrategy">Decoding Strategy</label>
              <select id="bStrategy">
                <option value="greedy" selected>Greedy</option>
                <option value="beam">Beam Search</option>
                <option value="topk">Top-k</option>
                <option value="topp">Top-p (Nucleus)</option>
                <option value="sample">Pure Sampling</option>
              </select>
            </div>

            <div class="field">
              <label for="bMaxTokens">Max Tokens: <span id="bMaxTokensVal">100</span></label>
              <input id="bMaxTokens" type="range" min="20" max="200" step="10" value="100" />
            </div>

            <div id="bTempWrap" class="field">
              <label for="bTemp">Temperature: <span id="bTempVal">1.00</span></label>
              <input id="bTemp" type="range" min="0" max="2.0" step="0.05" value="1.00" />
            </div>

            <div id="bTopkWrap" class="field">
              <label for="bTopk">Top-k: <span id="bTopkVal">40</span></label>
              <input id="bTopk" type="range" min="1" max="320" step="1" value="40" />
            </div>

            <div id="bToppWrap" class="field">
              <label for="bTopp">Top-p: <span id="bToppVal">0.95</span></label>
              <input id="bTopp" type="range" min="0.10" max="1.00" step="0.01" value="0.95" />
            </div>

            <div id="bBeamWrap" class="field">
              <label for="bBeam">Beam Size (b): <span id="bBeamVal">4</span></label>
              <input id="bBeam" type="range" min="1" max="16" step="1" value="4" />
            </div>

          </div>
        </article>
      </div>
    </section>

    <section id="tab2" class="panel">
      <div class="card">
        <div class="arena-head">
          <div style="display:grid;gap:8px;">
            <div class="chip">Blind decoding preference arena</div>
            <div class="arena-score">
              Round <span id="roundNum">1</span>/5 · Selections <span id="scoreNum">0</span>
              <span id="roundResult" style="margin-left:8px;"></span>
            </div>
          </div>

          <div style="display:grid;gap:8px;min-width:270px;">
            <div class="field">
              <label for="arenaPair">Method Pair</label>
              <select id="arenaPair">
                <option value="random_blind">Random Pair (Blind)</option>
                <option value="topp_vs_greedy">Top-p vs Greedy</option>
                <option value="sample_vs_greedy">Pure Sampling vs Greedy</option>
                <option value="sample_vs_topp">Pure Sampling vs Top-p</option>
                <option value="beam_vs_greedy">Beam Search vs Greedy</option>
                <option value="topk_vs_greedy">Top-k vs Greedy</option>
                <option value="topp_vs_topk">Top-p vs Top-k</option>
                <option value="beam_vs_topp">Beam Search vs Top-p</option>
              </select>
            </div>
            <div class="field">
              <label for="arenaMaxTokens">Token Limit: <span id="arenaMaxTokensVal">90</span></label>
              <input id="arenaMaxTokens" type="range" min="20" max="200" step="10" value="90" />
            </div>
            <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:8px;">
              <button id="genRound" class="primary">Generate Round</button>
              <button id="nextRound">Next Round</button>
              <button id="restartArena">Restart</button>
            </div>
          </div>
        </div>

        <div class="arena-grid">
          <button id="pickLeft" class="card arena-option">
            <h4>Option Left</h4>
            <div id="leftMeta" class="arena-meta"></div>
            <div id="leftText" class="mono"></div>
          </button>

          <button id="pickRight" class="card arena-option">
            <h4>Option Right</h4>
            <div id="rightMeta" class="arena-meta"></div>
            <div id="rightText" class="mono"></div>
          </button>
        </div>

        <div id="arenaStatus" class="status"></div>
        <div id="revealBox" class="status" style="font-weight:700;"></div>
      </div>
    </section>

    <section id="tab3" class="panel active">
      <div class="dist-layout">
        <div class="card">
          <div class="field">
            <label for="distTemplate">Prompt Template</label>
            <select id="distTemplate">
              <option value="paper_unicorn">Paper · In a shocking finding, scientists discovered</option>
              <option value="paper_university">Paper · The university said in a statement that</option>
              <option value="paper_city">Paper · The city council announced that</option>
              <option value="paper_museum">Paper · The museum curator explained that</option>
              <option value="paper_story">Paper · Once upon a time, in a small village</option>
              <option value="paper_essay">Paper · The meaning of life is</option>
              <option value="paper_news">Paper · The report found that</option>
              <option value="paper_fig5_flat">Paper Fig 5 · She said, \" I never</option>
              <option value="paper_fig5_peaked">Paper Fig 5 · I ate the pizza while it was still</option>
              <option value="paper_appendix_life">Paper Appendix · So what's new in my life?</option>
              <option value="paper_appendix_vacation">Paper Appendix · Just got back from vacation.</option>
              <option value="paper_appendix_wallpaper">Paper Appendix · How can I change the background wallpaper</option>
              <option value="city_billboard">Reactive city billboard story</option>
              <option value="receipt_poetry">Receipt poetry at midnight</option>
              <option value="satellite_last">Satellite final message</option>
              <option value="museum_diary">Museum digitized diaries</option>
              <option value="weather_mood">Weather report predicts moods</option>
            </select>
          </div>

          <div class="field">
            <label for="distPrompt">Distribution Prompt</label>
            <textarea id="distPrompt">The report found that when language models are decoded greedily, they often</textarea>
          </div>

          <div class="dist-output-grid">
            <div id="tailChart"></div>
            <div class="card dist-readouts">
              <div id="selectedTokenStatus" class="status"></div>
              <div id="distStatus" class="status"></div>
              <div id="nextTokenStatus" class="status"></div>
              <div class="kpis">
                <div class="kpi">Nucleus length: <strong id="nucleusLen">0</strong></div>
                <div class="kpi">Top-k length: <strong id="topkLen">0</strong></div>
                <div class="kpi">Entropy: <strong id="entropyBits">0.00</strong> bits</div>
              </div>
            </div>
          </div>
        </div>

        <div class="card">
          <div class="dist-controls-grid">
            <div class="field">
              <label for="distN">Top Candidates: <span id="distNVal">60</span></label>
              <input id="distN" type="range" min="10" max="320" step="5" value="60" />
            </div>

            <div class="field">
              <label for="kCut">Top-k Overlay: <span id="kCutVal">30</span></label>
              <input id="kCut" type="range" min="1" max="320" step="1" value="30" />
            </div>

            <div class="field">
              <label for="pCut">Top-p Overlay: <span id="pCutVal">0.90</span></label>
              <input id="pCut" type="range" min="0.10" max="1.00" step="0.01" value="0.90" />
            </div>

            <div class="field">
              <label for="nextTokenStrategy">Next Token Strategy</label>
              <select id="nextTokenStrategy">
                <option value="greedy">Greedy</option>
                <option value="beam">Beam Search</option>
                <option value="topk">Top-k</option>
                <option value="topp" selected>Top-p (Nucleus)</option>
                <option value="sample">Pure Sampling</option>
                <option value="chart_click">Chart Click (Selected Token)</option>
              </select>
              <div id="nextStrategyHint" class="param-hint"></div>
            </div>
          </div>

          <div class="dist-actions">
            <button id="generateNextToken">Generate Next Token</button>
            <button id="undoToken">Undo Last Token</button>
          </div>
        </div>
      </div>
    </section>

    <section id="tab4" class="panel">
      <div class="wm-grid">
        <div class="card">
          <div class="field">
            <label for="wmTemplate">Prompt Template</label>
            <select id="wmTemplate">
              <option value="paper_appendix_life">Paper Appendix · So what's new in my life?</option>
              <option value="paper_unicorn">Paper · In a shocking finding, scientists discovered</option>
              <option value="paper_university">Paper · The university said in a statement that</option>
              <option value="paper_city">Paper · The city council announced that</option>
              <option value="paper_fig5_flat">Paper Fig 5 · She said, " I never</option>
              <option value="paper_fig5_peaked">Paper Fig 5 · I ate the pizza while it was still</option>
              <option value="city_billboard">Reactive city billboard story</option>
            </select>
          </div>
          <div class="field">
            <label for="wmPrompt">Watermark Prompt</label>
            <textarea id="wmPrompt">So what's new in my life?</textarea>
          </div>

          <div class="field">
            <label for="wmStrategy">Decoding Strategy</label>
            <select id="wmStrategy">
              <option value="topp">Top-p (Nucleus)</option>
              <option value="topk">Top-k</option>
              <option value="greedy" selected>Greedy</option>
              <option value="sample">Pure Sampling</option>
            </select>
          </div>
          <div class="field">
            <label for="wmMaxTokens">Max Tokens: <span id="wmMaxTokensVal">80</span></label>
            <input id="wmMaxTokens" type="range" min="10" max="200" step="10" value="80" />
          </div>
          <div class="field">
            <label for="wmTemp">Temperature: <span id="wmTempVal">1.00</span></label>
            <input id="wmTemp" type="range" min="0.00" max="2.00" step="0.05" value="1.00" />
          </div>
          <div class="field" id="wmTopPWrap">
            <label for="wmTopP">Top-p: <span id="wmTopPVal">0.95</span></label>
            <input id="wmTopP" type="range" min="0.10" max="1.00" step="0.01" value="0.95" />
          </div>
          <div class="field" id="wmTopKWrap">
            <label for="wmTopK">Top-k: <span id="wmTopKVal">40</span></label>
            <input id="wmTopK" type="range" min="1" max="320" step="1" value="40" />
          </div>
          <div class="field">
            <label for="wmGamma">Gamma (green ratio): <span id="wmGammaVal">0.25</span></label>
            <input id="wmGamma" type="range" min="0.05" max="0.80" step="0.01" value="0.25" />
          </div>
          <div class="field">
            <label for="wmDelta">Delta (bias): <span id="wmDeltaVal">2.00</span></label>
            <input id="wmDelta" type="range" min="0.00" max="5.00" step="0.10" value="2.00" />
          </div>
          <div class="field">
            <label for="wmKey">Seeding Key</label>
            <input id="wmKey" type="text" value="15485863" />
          </div>

          <button id="wmGenerate" class="primary">Generate Watermarked Text</button>
          <div id="wmStatus" class="status"></div>
        </div>

        <div class="card">
          <div class="wm-legend">
            <span><span class="wm-token green">green</span> in greenlist</span>
            <span><span class="wm-token red">red</span> out of greenlist</span>
          </div>
          <div class="wm-compare">
            <div class="wm-col">
              <h4>KGW Watermarked</h4>
              <div id="wmOutput" class="mono wm-output"></div>
            </div>
            <div class="wm-col">
              <h4>No Watermark Baseline</h4>
              <div id="wmOutputPlain" class="mono wm-output"></div>
            </div>
          </div>
          <div id="wmMetrics" class="metrics"></div>
        </div>
      </div>
    </section>
  </div>
  <footer class="site-footer">Made with ❤️ for CPSC 532B · Decoding Dashboard Explorer</footer>

  <script>
    const $ = (id) => document.getElementById(id);

    const tabs = [...document.querySelectorAll('.tab-btn')];
    const panels = [...document.querySelectorAll('.panel')];

    function setActiveTab(tabId) {
      tabs.forEach((b) => b.classList.toggle('active', b.dataset.tab === tabId));
      panels.forEach((p) => p.classList.toggle('active', p.id === tabId));
      if (tabId === 'tab3') {
        fetchRealDistribution();
      }
    }

    tabs.forEach((btn) => btn.addEventListener('click', () => setActiveTab(btn.dataset.tab)));

    function apiConfig() {
      return { model: $('model').value.trim() || 'gpt2-large' };
    }

    function applyTheme(theme) {
      const normalized = (theme || 'forest').toLowerCase();
      if (normalized === 'forest') {
        document.body.removeAttribute('data-theme');
      } else {
        document.body.setAttribute('data-theme', normalized);
      }
      if (distTokens.length) {
        drawDistribution();
      }
      try {
        localStorage.setItem('decoding_theme', normalized);
      } catch (_) {}
    }

    function strategyLabel(v) {
      if (v === 'greedy') return 'Greedy';
      if (v === 'beam') return 'Beam Search';
      if (v === 'topk') return 'Top-k';
      if (v === 'sample') return 'Pure Sampling';
      return 'Top-p (Nucleus)';
    }

    function attachRange(rangeId, valueId, formatter) {
      const range = $(rangeId);
      const value = $(valueId);
      const update = () => {
        value.textContent = formatter ? formatter(Number(range.value)) : range.value;
      };
      range.addEventListener('input', update);
      update();
    }

    attachRange('aTemp', 'aTempVal', (v) => v.toFixed(2));
    attachRange('aTopk', 'aTopkVal');
    attachRange('aTopp', 'aToppVal', (v) => v.toFixed(2));
    attachRange('aBeam', 'aBeamVal');
    attachRange('aMaxTokens', 'aMaxTokensVal');
    attachRange('bTemp', 'bTempVal', (v) => v.toFixed(2));
    attachRange('bTopk', 'bTopkVal');
    attachRange('bTopp', 'bToppVal', (v) => v.toFixed(2));
    attachRange('bBeam', 'bBeamVal');
    attachRange('bMaxTokens', 'bMaxTokensVal');
    attachRange('distN', 'distNVal');
    attachRange('kCut', 'kCutVal');
    attachRange('pCut', 'pCutVal', (v) => v.toFixed(2));
    attachRange('arenaMaxTokens', 'arenaMaxTokensVal');
    attachRange('wmMaxTokens', 'wmMaxTokensVal');
    attachRange('wmTemp', 'wmTempVal', (v) => v.toFixed(2));
    attachRange('wmTopP', 'wmTopPVal', (v) => v.toFixed(2));
    attachRange('wmTopK', 'wmTopKVal');
    attachRange('wmGamma', 'wmGammaVal', (v) => v.toFixed(2));
    attachRange('wmDelta', 'wmDeltaVal', (v) => v.toFixed(2));

    function mergePromptCompletion(prompt, completion) {
      const p = (prompt || '').trim();
      const c = (completion || '').trim();
      if (!p) return c;
      if (!c) return p;
      if (c.toLowerCase().startsWith(p.toLowerCase())) return c;
      return `${p} ${c}`.trim();
    }

    const promptTemplates = {
      paper_unicorn: 'In a shocking finding, scientists discovered',
      paper_university: 'The university said in a statement that',
      paper_city: 'The city council announced that',
      paper_museum: 'The museum curator explained that',
      paper_story: 'Once upon a time, in a small village',
      paper_essay: 'The meaning of life is',
      paper_news: 'The report found that',
      paper_fig5_flat: 'She said, " I never',
      paper_fig5_peaked: 'I ate the pizza while it was still',
      paper_appendix_life: "So what's new in my life?",
      paper_appendix_vacation: 'Just got back from vacation.',
      paper_appendix_wallpaper: 'How can I change the background wallpaper for my screen?',
      city_billboard: 'In a city where every billboard can write back, a teenager discovers',
      receipt_poetry: 'At midnight the chatbot started writing poetry on receipts, and by dawn',
      satellite_last: 'A satellite with a sense of humor sent one final message:',
      museum_diary: 'When the museum digitized every diary, historians were shocked because',
      weather_mood: 'The AI weather report stopped predicting rain and started predicting moods.'
    };

    function escapeHtml(text) {
      return String(text || '')
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    }

    function tokenWords(text) {
      return (text || '')
        .toLowerCase()
        .replace(/[^a-z0-9'\s]/g, ' ')
        .split(/\s+/)
        .filter(Boolean);
    }

    function ngramRepetition(words, n) {
      if (words.length < n) return 0;
      const counts = new Map();
      const grams = [];
      for (let i = 0; i <= words.length - n; i += 1) {
        const gram = words.slice(i, i + n).join('|');
        grams.push(gram);
        counts.set(gram, (counts.get(gram) || 0) + 1);
      }
      let repeated = 0;
      for (const gram of grams) {
        if ((counts.get(gram) || 0) > 1) repeated += 1;
      }
      return repeated / grams.length;
    }

    function zipfCoefficient(words) {
      if (!words.length) return 0;
      const counts = new Map();
      for (const w of words) counts.set(w, (counts.get(w) || 0) + 1);
      const freqs = [...counts.values()].sort((a, b) => b - a);
      if (freqs.length < 2) return 0;
      let sumX = 0;
      let sumY = 0;
      let sumXY = 0;
      let sumXX = 0;
      const n = freqs.length;
      for (let i = 0; i < n; i += 1) {
        const x = Math.log(i + 1);
        const y = Math.log(freqs[i]);
        sumX += x;
        sumY += y;
        sumXY += x * y;
        sumXX += x * x;
      }
      const denom = (n * sumXX) - (sumX * sumX);
      if (!Number.isFinite(denom) || Math.abs(denom) < 1e-12) return 0;
      const slope = ((n * sumXY) - (sumX * sumY)) / denom;
      return -slope;
    }

    function readSample(prefix) {
      return {
        prompt: ($('sharedPrompt').value || '').trim() || 'Once upon a time',
        strategy: $(`${prefix}Strategy`).value,
        max_tokens: Number($(`${prefix}MaxTokens`).value),
        temperature: Number($(`${prefix}Temp`).value),
        top_k: Number($(`${prefix}Topk`).value),
        top_p: Number($(`${prefix}Topp`).value),
        beam_size: Number($(`${prefix}Beam`).value),
      };
    }

    function buildDecodePayload(cfg) {
      const body = {
        model: apiConfig().model,
        prompt: cfg.prompt,
        max_tokens: cfg.max_tokens,
        strategy: cfg.strategy,
      };
      if (cfg.strategy === 'greedy') {
        body.temperature = 0;
        body.top_p = 1;
        return body;
      }
      if (cfg.strategy === 'beam') {
        body.temperature = 0;
        body.top_p = 1;
        body.beam_size = Math.max(1, Number(cfg.beam_size) || 4);
        return body;
      }
      if (cfg.strategy === 'topk') {
        body.temperature = cfg.temperature;
        body.top_p = 1;
        body.top_k = cfg.top_k;
        return body;
      }
      if (cfg.strategy === 'sample') {
        body.temperature = cfg.temperature;
        body.top_p = 1;
        return body;
      }
      if (cfg.strategy === 'topp') {
        body.temperature = cfg.temperature;
        body.top_p = cfg.top_p;
        return body;
      }
      throw new Error(`Unsupported strategy: ${cfg.strategy}`);
    }

    async function localChat(cfg) {
      const res = await fetch('/api/local/completions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(buildDecodePayload(cfg)),
      });
      if (!res.ok) throw new Error(`HTTP ${res.status}: ${(await res.text()).slice(0, 220)}`);
      const data = await res.json();
      const text = data?.choices?.[0]?.text || '';
      return {
        fullText: mergePromptCompletion(cfg.prompt, text),
        usage: data?.usage || null,
        performance: data?.performance || null,
      };
    }

    async function localChatStream(cfg, onDelta, onStatus) {
      const res = await fetch('/api/local/completions_stream', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(buildDecodePayload(cfg)),
      });
      if (!res.ok) throw new Error(`HTTP ${res.status}: ${(await res.text()).slice(0, 220)}`);
      if (!res.body) throw new Error('Streaming response body unavailable.');

      const reader = res.body.getReader();
      const decoder = new TextDecoder();
      let buffer = '';
      let completion = '';
      let usage = null;
      let performance = null;
      let doneSignal = false;

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        buffer += decoder.decode(value, { stream: true }).replace(/\r\n/g, '\n');

        while (true) {
          const splitAt = buffer.indexOf('\n\n');
          if (splitAt === -1) break;
          const packet = buffer.slice(0, splitAt);
          buffer = buffer.slice(splitAt + 2);

          for (const line of packet.split('\n')) {
            if (!line.startsWith('data: ')) continue;
            const payload = JSON.parse(line.slice(6));

            if (payload.type === 'delta') {
              completion += payload.text || '';
              if (onDelta) onDelta(completion);
            } else if (payload.type === 'status') {
              if (onStatus) onStatus(payload);
            } else if (payload.type === 'done') {
              usage = payload.usage || null;
              performance = payload.performance || null;
              doneSignal = true;
            } else if (payload.type === 'error') {
              throw new Error(payload.error || 'Streaming generation failed.');
            }
          }
        }

        if (doneSignal) {
          try { await reader.cancel(); } catch (_) {}
          break;
        }
      }

      return {
        fullText: mergePromptCompletion(cfg.prompt, completion),
        usage,
        performance,
      };
    }

    function metricPills(container, text, performance, usage) {
      const words = tokenWords(text);
      const rep2 = ngramRepetition(words, 2);
      const rep3 = ngramRepetition(words, 3);
      const rep4 = ngramRepetition(words, 4);
      const zipf = zipfCoefficient(words);

      const metrics = [
        `Zipf coef ${zipf.toFixed(2)}`,
        `Rep-2 ${(rep2 * 100).toFixed(1)}%`,
        `Rep-3 ${(rep3 * 100).toFixed(1)}%`,
        `Rep-4 ${(rep4 * 100).toFixed(1)}%`,
        `Words ${words.length}`,
      ];

      if (performance?.tokens_per_second != null) metrics.push(`Tok/s ${Number(performance.tokens_per_second).toFixed(1)}`);
      if (usage?.completion_tokens != null) metrics.push(`Generated ${usage.completion_tokens}`);

      container.innerHTML = metrics.map((m) => `<span class="metric">${m}</span>`).join('');
    }

    function updateSampleTitle(prefix) {
      const cfg = readSample(prefix);
      const label = strategyLabel(cfg.strategy);
      $(`sample${prefix.toUpperCase()}Title`).textContent = `Sample ${prefix.toUpperCase()} · ${label}`;
    }

    const SAMPLE_STRATEGY_UI = {
      greedy: { temp: false, topk: false, topp: false, beam: false },
      beam: { temp: false, topk: false, topp: false, beam: true },
      topk: { temp: true, topk: true, topp: false, beam: false },
      topp: { temp: true, topk: false, topp: true, beam: false },
      sample: { temp: true, topk: false, topp: false, beam: false },
    };

    const WM_STRATEGY_UI = {
      greedy: { temp: false, topk: false, topp: false },
      topk: { temp: true, topk: true, topp: false },
      topp: { temp: true, topk: false, topp: true },
      sample: { temp: true, topk: false, topp: false },
    };

    function updateMethodControls(prefix) {
      const strategy = $(`${prefix}Strategy`).value;
      const cfg = SAMPLE_STRATEGY_UI[strategy] || SAMPLE_STRATEGY_UI.topp;
      $(`${prefix}TempWrap`).style.display = cfg.temp ? '' : 'none';
      $(`${prefix}TopkWrap`).style.display = cfg.topk ? '' : 'none';
      $(`${prefix}ToppWrap`).style.display = cfg.topp ? '' : 'none';
      $(`${prefix}BeamWrap`).style.display = cfg.beam ? '' : 'none';
    }

    function updateWmControls() {
      const strategy = $('wmStrategy').value;
      const cfg = WM_STRATEGY_UI[strategy] || WM_STRATEGY_UI.topp;
      $('wmTemp').closest('.field').style.display = cfg.temp ? '' : 'none';
      $('wmTopKWrap').style.display = cfg.topk ? '' : 'none';
      $('wmTopPWrap').style.display = cfg.topp ? '' : 'none';
    }

    ['aStrategy', 'aTemp', 'aTopk', 'aTopp', 'aBeam'].forEach((id) => $(id).addEventListener('input', () => updateSampleTitle('a')));
    ['bStrategy', 'bTemp', 'bTopk', 'bTopp', 'bBeam'].forEach((id) => $(id).addEventListener('input', () => updateSampleTitle('b')));
    $('aStrategy').addEventListener('change', () => { updateSampleTitle('a'); updateMethodControls('a'); });
    $('bStrategy').addEventListener('change', () => { updateSampleTitle('b'); updateMethodControls('b'); });
    $('wmStrategy').addEventListener('change', updateWmControls);

    const genStatusEl = $('genStatus');

    async function runSingle(prefix, fromBatch = false) {
      const cfg = readSample(prefix);
      const outputEl = $(`sample${prefix.toUpperCase()}`);
      const metricsEl = $(`metrics${prefix.toUpperCase()}`);
      const statusEl = $(`status${prefix.toUpperCase()}`);
      const button = $(`generate${prefix.toUpperCase()}`);

      updateSampleTitle(prefix);
      outputEl.textContent = 'Generating...';
      outputEl.classList.add('generating');
      metricsEl.innerHTML = '';
      statusEl.textContent = 'Generating...';
      statusEl.classList.remove('error');

      if (!fromBatch) button.disabled = true;

      try {
        const out = await localChatStream(
          cfg,
          (partial) => {
            outputEl.textContent = mergePromptCompletion(cfg.prompt, partial);
          },
          (status) => {
            if (status?.message === 'loading_runtime') statusEl.textContent = 'Loading runtime...';
            if (status?.message === 'runtime_ready') statusEl.textContent = `Running on ${status.device || 'device'}...`;
          }
        );

        outputEl.textContent = out.fullText;
        outputEl.classList.remove('generating');
        metricPills(metricsEl, out.fullText, out.performance, out.usage);
        statusEl.textContent = 'Done.';
        return out;
      } catch (err) {
        outputEl.classList.remove('generating');
        statusEl.textContent = `Failed: ${err.message}`;
        statusEl.classList.add('error');
        throw err;
      } finally {
        if (!fromBatch) button.disabled = false;
      }
    }

    async function runBoth() {
      genStatusEl.textContent = 'Running both samples...';
      $('generateBoth').disabled = true;
      $('generateA').disabled = true;
      $('generateB').disabled = true;

      try {
        await runSingle('a', true);
        await runSingle('b', true);
        genStatusEl.textContent = 'Both samples updated.';
      } catch (err) {
        genStatusEl.textContent = `Failed: ${err.message}`;
      } finally {
        $('generateBoth').disabled = false;
        $('generateA').disabled = false;
        $('generateB').disabled = false;
      }
    }

    $('generateA').addEventListener('click', () => runSingle('a'));
    $('generateB').addEventListener('click', () => runSingle('b'));
    $('generateBoth').addEventListener('click', runBoth);
    $('promptTemplate').addEventListener('change', () => {
      const key = $('promptTemplate').value;
      if (promptTemplates[key]) {
        $('sharedPrompt').value = promptTemplates[key];
        genStatusEl.textContent = 'Template applied to shared prompt.';
      }
    });
    $('distTemplate').addEventListener('change', () => {
      const key = $('distTemplate').value;
      if (promptTemplates[key]) {
        $('distPrompt').value = promptTemplates[key];
        $('nextTokenStatus').textContent = 'Template applied to distribution prompt.';
        fetchRealDistribution();
      }
    });
    $('wmTemplate').addEventListener('change', () => {
      const key = $('wmTemplate').value;
      if (promptTemplates[key]) {
        $('wmPrompt').value = promptTemplates[key];
        $('wmStatus').textContent = 'Template applied to watermark prompt.';
      }
    });
    $('themeSelect').addEventListener('change', () => applyTheme($('themeSelect').value));

    $('preloadModel').addEventListener('click', async () => {
      const connStatus = $('connStatus');
      connStatus.textContent = 'Loading model...';
      drawChartMessage(`Loading model: ${apiConfig().model}...`);
      $('distStatus').textContent = 'Waiting for model to load...';
      try {
        const res = await fetch('/api/local/health', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ model: apiConfig().model, preload: true }),
        });
        if (!res.ok) throw new Error(await res.text());
        const payload = await res.json();
        connStatus.textContent = `Loaded on ${payload.device || 'device'} in ${payload.loaded_in_s || '?'}s`;
        await fetchRealDistribution();
      } catch (err) {
        connStatus.textContent = `Load failed: ${err.message}`;
      }
    });

    async function checkApiServer() {
      try {
        const res = await fetch('/api/local/health', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ model: apiConfig().model }),
        });
        $('serverWarning').textContent = res.status === 404
          ? 'Wrong server detected. Start the local backend server in this folder.'
          : '';
      } catch (_) {
        $('serverWarning').textContent = '';
      }
    }

    const arenaPrompts = [
      promptTemplates.paper_unicorn,
      promptTemplates.paper_university,
      promptTemplates.paper_city,
      promptTemplates.paper_museum,
      promptTemplates.paper_story,
      promptTemplates.paper_essay,
      promptTemplates.paper_news,
      promptTemplates.paper_fig5_flat,
      promptTemplates.paper_fig5_peaked,
      promptTemplates.paper_appendix_life,
      promptTemplates.paper_appendix_vacation,
      promptTemplates.paper_appendix_wallpaper,
      promptTemplates.city_billboard,
      promptTemplates.receipt_poetry,
      promptTemplates.satellite_last,
      promptTemplates.museum_diary,
      promptTemplates.weather_mood,
    ];

    let round = 0;
    let score = 0;
    const MAX_ARENA_ROUNDS = 5;
    let arenaRound = 0;
    let roundPicked = false;
    let arenaFinished = false;
    let randomArenaPairKey = null;
    let leftMethod = 'Top-p (Nucleus)';
    let rightMethod = 'Greedy';
    const methodWins = {
      'Greedy': 0,
      'Beam Search': 0,
      'Top-k': 0,
      'Top-p (Nucleus)': 0,
      'Pure Sampling': 0,
    };

    function arenaPairConfigs(prompt) {
      const pair = $('arenaPair').value;
      const model = apiConfig().model;
      const arenaMaxTokens = Number($('arenaMaxTokens').value);

      const greedy = {
        model,
        prompt,
        strategy: 'greedy',
        temperature: 0,
        top_k: 40,
        top_p: 1,
        max_tokens: arenaMaxTokens,
      };
      const topp = {
        model,
        prompt,
        strategy: 'topp',
        temperature: 0.95,
        top_k: 40,
        top_p: 0.95,
        max_tokens: arenaMaxTokens,
      };
      const beam = {
        model,
        prompt,
        strategy: 'beam',
        temperature: 0,
        top_k: 0,
        top_p: 1,
        beam_size: 4,
        max_tokens: arenaMaxTokens,
      };
      const topk = {
        model,
        prompt,
        strategy: 'topk',
        temperature: 0.95,
        top_k: 40,
        top_p: 1,
        max_tokens: arenaMaxTokens,
      };
      const sample = {
        model,
        prompt,
        strategy: 'sample',
        temperature: 1.0,
        top_k: 0,
        top_p: 1,
        max_tokens: arenaMaxTokens,
      };
      const pool = [
        { left: topp, right: greedy, leftName: 'Top-p (Nucleus)', rightName: 'Greedy' },
        { left: sample, right: greedy, leftName: 'Pure Sampling', rightName: 'Greedy' },
        { left: sample, right: topp, leftName: 'Pure Sampling', rightName: 'Top-p (Nucleus)' },
        { left: beam, right: greedy, leftName: 'Beam Search', rightName: 'Greedy' },
        { left: topk, right: greedy, leftName: 'Top-k', rightName: 'Greedy' },
        { left: topp, right: topk, leftName: 'Top-p (Nucleus)', rightName: 'Top-k' },
        { left: beam, right: topp, leftName: 'Beam Search', rightName: 'Top-p (Nucleus)' },
      ];
      if (pair === 'random_blind') {
        if (randomArenaPairKey == null) {
          randomArenaPairKey = Math.floor(Math.random() * pool.length);
        }
        const picked = pool[randomArenaPairKey];
        return { ...picked, randomPair: true };
      }
      if (pair === 'topk_vs_greedy') {
        return { left: topk, right: greedy, leftName: 'Top-k', rightName: 'Greedy' };
      }
      if (pair === 'beam_vs_greedy') {
        return { left: beam, right: greedy, leftName: 'Beam Search', rightName: 'Greedy' };
      }
      if (pair === 'beam_vs_topp') {
        return { left: beam, right: topp, leftName: 'Beam Search', rightName: 'Top-p (Nucleus)' };
      }
      if (pair === 'sample_vs_greedy') {
        return { left: sample, right: greedy, leftName: 'Pure Sampling', rightName: 'Greedy' };
      }
      if (pair === 'sample_vs_topp') {
        return { left: sample, right: topp, leftName: 'Pure Sampling', rightName: 'Top-p (Nucleus)' };
      }
      if (pair === 'topp_vs_topk') {
        return { left: topp, right: topk, leftName: 'Top-p (Nucleus)', rightName: 'Top-k' };
      }
      randomArenaPairKey = null;
      return { left: topp, right: greedy, leftName: 'Top-p (Nucleus)', rightName: 'Greedy' };
    }

    async function loadRound() {
      if (arenaFinished) return;
      const prompt = arenaPrompts[round];
      const pair = arenaPairConfigs(prompt);
      let leftIsPrimary = Math.random() > 0.5;

      roundPicked = false;
      $('pickLeft').disabled = false;
      $('pickRight').disabled = false;
      $('roundNum').textContent = String(arenaRound + 1);
      $('roundResult').textContent = '';
      $('revealBox').textContent = '';
      $('arenaStatus').textContent = pair.randomPair
        ? 'Generating round with a hidden random method pair...'
        : 'Generating round...';
      $('leftMeta').textContent = '';
      $('rightMeta').textContent = '';
      $('leftText').textContent = 'Generating...';
      $('rightText').textContent = 'Generating...';

      const first = leftIsPrimary ? pair.left : pair.right;
      const second = leftIsPrimary ? pair.right : pair.left;
      leftMethod = leftIsPrimary ? pair.leftName : pair.rightName;
      rightMethod = leftIsPrimary ? pair.rightName : pair.leftName;
      try {
        const [outFirst, outSecond] = await Promise.all([localChat(first), localChat(second)]);

        if (leftIsPrimary) {
          $('leftText').textContent = outFirst.fullText;
          $('leftMeta').textContent = `Tok/s ${Number(outFirst?.performance?.tokens_per_second || 0).toFixed(1)} · Generated ${Number(outFirst?.usage?.completion_tokens || 0)}`;
          $('rightText').textContent = outSecond.fullText;
          $('rightMeta').textContent = `Tok/s ${Number(outSecond?.performance?.tokens_per_second || 0).toFixed(1)} · Generated ${Number(outSecond?.usage?.completion_tokens || 0)}`;
        } else {
          $('leftText').textContent = outSecond.fullText;
          $('leftMeta').textContent = `Tok/s ${Number(outSecond?.performance?.tokens_per_second || 0).toFixed(1)} · Generated ${Number(outSecond?.usage?.completion_tokens || 0)}`;
          $('rightText').textContent = outFirst.fullText;
          $('rightMeta').textContent = `Tok/s ${Number(outFirst?.performance?.tokens_per_second || 0).toFixed(1)} · Generated ${Number(outFirst?.usage?.completion_tokens || 0)}`;
        }

        $('arenaStatus').textContent = 'Round ready.';
      } catch (err) {
        $('arenaStatus').textContent = `Failed: ${err.message}`;
      }
    }

    function evaluatePick(pickedLeft) {
      if (arenaFinished || roundPicked) return;
      const guess = pickedLeft ? leftMethod : rightMethod;
      methodWins[guess] = (methodWins[guess] || 0) + 1;
      score += 1;
      roundPicked = true;
      $('pickLeft').disabled = true;
      $('pickRight').disabled = true;
      const winner = Object.entries(methodWins).sort((a, b) => b[1] - a[1])[0];

      $('scoreNum').textContent = String(score);
      $('roundResult').textContent = `You picked ${guess} as more human-like.`;
      $('roundResult').className = 'result-ok';
      $('revealBox').innerHTML =
        `Left uses <strong>${leftMethod}</strong> | Right uses <strong>${rightMethod}</strong><br>` +
        `Current winner: <strong>${winner[0]}</strong> (${winner[1]} votes) · ` +
        `Greedy ${methodWins['Greedy']} | Beam ${methodWins['Beam Search']} | Top-k ${methodWins['Top-k']} | Top-p ${methodWins['Top-p (Nucleus)']} | Sampling ${methodWins['Pure Sampling']}`;

      if (arenaRound >= MAX_ARENA_ROUNDS - 1) {
        arenaFinished = true;
        $('nextRound').disabled = true;
        $('genRound').disabled = true;
        $('arenaStatus').textContent = `Finished ${MAX_ARENA_ROUNDS} rounds.`;
        $('revealBox').innerHTML += `<div class="winner-banner">Final Winner: ${winner[0]}</div>`;
      }
    }

    $('pickLeft').addEventListener('click', () => evaluatePick(true));
    $('pickRight').addEventListener('click', () => evaluatePick(false));
    $('genRound').addEventListener('click', loadRound);
    $('nextRound').addEventListener('click', () => {
      if (arenaFinished) return;
      if (!roundPicked) {
        $('arenaStatus').textContent = 'Pick one option first, then go to next round.';
        return;
      }
      arenaRound += 1;
      if (arenaRound >= MAX_ARENA_ROUNDS) return;
      round = (round + 1) % arenaPrompts.length;
      loadRound();
    });
    $('restartArena').addEventListener('click', () => {
      round = 0;
      arenaRound = 0;
      score = 0;
      roundPicked = false;
      arenaFinished = false;
      randomArenaPairKey = null;
      Object.keys(methodWins).forEach((k) => { methodWins[k] = 0; });
      $('scoreNum').textContent = '0';
      $('roundNum').textContent = '1';
      $('roundResult').textContent = '';
      $('revealBox').textContent = '';
      $('arenaStatus').textContent = 'Arena reset. Generate round 1.';
      $('leftText').textContent = '';
      $('rightText').textContent = '';
      $('leftMeta').textContent = '';
      $('rightMeta').textContent = '';
      $('nextRound').disabled = false;
      $('genRound').disabled = false;
      $('pickLeft').disabled = false;
      $('pickRight').disabled = false;
    });

    async function generateWatermarked() {
      const statusEl = $('wmStatus');
      const outEl = $('wmOutput');
      const outPlainEl = $('wmOutputPlain');
      const metricsEl = $('wmMetrics');
      $('wmGenerate').disabled = true;
      statusEl.textContent = 'Generating with KGW watermark...';
      outEl.textContent = 'Generating...';
      outPlainEl.textContent = 'Generating...';
      outEl.classList.add('generating');
      outPlainEl.classList.add('generating');
      metricsEl.innerHTML = '';
      try {
        const body = {
          model: apiConfig().model,
          prompt: ($('wmPrompt').value || '').trim() || "So what's new in my life?",
          strategy: $('wmStrategy').value,
          max_tokens: Number($('wmMaxTokens').value),
          temperature: Number($('wmTemp').value),
          top_p: Number($('wmTopP').value),
          top_k: Number($('wmTopK').value),
          gamma: Number($('wmGamma').value),
          delta: Number($('wmDelta').value),
          seeding_key: Number(($('wmKey').value || '15485863').trim()) || 15485863,
        };
        const res = await fetch('/api/local/watermark/completions_stream', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body),
        });
        if (!res.ok) throw new Error(`HTTP ${res.status}: ${(await res.text()).slice(0, 220)}`);
        if (!res.body) throw new Error('Streaming response body unavailable.');

        const reader = res.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';
        let wmHtml = '';
        let plainHtml = '';

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          buffer += decoder.decode(value, { stream: true }).replace(/\r\n/g, '\n');
          while (true) {
            const splitAt = buffer.indexOf('\n\n');
            if (splitAt === -1) break;
            const packet = buffer.slice(0, splitAt);
            buffer = buffer.slice(splitAt + 2);
            for (const line of packet.split('\n')) {
              if (!line.startsWith('data: ')) continue;
              const payload = JSON.parse(line.slice(6));
              if (payload.type === 'status') {
                statusEl.textContent = payload.message || statusEl.textContent;
              } else if (payload.type === 'delta_wm') {
                const cls = payload.green ? 'green' : 'red';
                wmHtml += `<span class="wm-token ${cls}">${escapeHtml(payload.text || '')}</span>`;
                outEl.innerHTML = wmHtml;
              } else if (payload.type === 'delta_plain') {
                const cls = payload.green ? 'green' : 'red';
                plainHtml += `<span class="wm-token ${cls}">${escapeHtml(payload.text || '')}</span>`;
                outPlainEl.innerHTML = plainHtml;
              } else if (payload.type === 'done') {
                const wm = payload.wm || {};
                const plain = payload.plain || {};
                const metrics = [];
                if (wm.tokens != null && wm.green_tokens != null) {
                  const rate = wm.tokens ? (100 * wm.green_tokens / wm.tokens) : 0;
                  metrics.push(`WM green ${wm.green_tokens}/${wm.tokens} (${rate.toFixed(1)}%)`);
                }
                if (plain.tokens != null && plain.green_tokens != null) {
                  const rate = plain.tokens ? (100 * plain.green_tokens / plain.tokens) : 0;
                  metrics.push(`Plain green ${plain.green_tokens}/${plain.tokens} (${rate.toFixed(1)}%)`);
                }
                if (wm.tokens_per_second != null) metrics.push(`WM Tok/s ${Number(wm.tokens_per_second).toFixed(1)}`);
                if (plain.tokens_per_second != null) metrics.push(`Plain Tok/s ${Number(plain.tokens_per_second).toFixed(1)}`);
                metricsEl.innerHTML = metrics.map((m) => `<span class="metric">${m}</span>`).join('');
                statusEl.textContent = 'Watermarked generation complete.';
                try { await reader.cancel(); } catch (_) {}
                break;
              } else if (payload.type === 'error') {
                throw new Error(payload.error || 'Watermark streaming failed.');
              }
            }
          }
        }
      } catch (err) {
          statusEl.textContent = `Failed: ${err.message}`;
          statusEl.classList.add('error');
        outEl.textContent = '';
        outPlainEl.textContent = '';
      } finally {
        outEl.classList.remove('generating');
        outPlainEl.classList.remove('generating');
        $('wmGenerate').disabled = false;
      }
    }

    $('wmGenerate').addEventListener('click', generateWatermarked);

    const tailChartEl = $('tailChart');
    let distTokens = [];
    let distMeta = { top_k_rank: 0, top_p_rank: 0, vocab_size: 0 };
    let distInFlight = false;
    let selectedChartToken = '';
    let distPromptHistory = [];
    let distRefreshTimer = null;
    let pendingDistRefresh = false;

    function localDistributionPayload(prompt, topN) {
      return {
        model: apiConfig().model,
        prompt,
        top_n: topN,
        top_k: Number($('kCut').value),
        top_p: Number($('pCut').value),
      };
    }

    async function fetchDistribution(prompt, topN) {
      const res = await fetch('/api/local/next-token-distribution', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(localDistributionPayload(prompt, topN)),
      });
      if (!res.ok) throw new Error(`HTTP ${res.status}: ${(await res.text()).slice(0, 220)}`);
      const data = await res.json();
      if (!Array.isArray(data?.tokens) || !data.tokens.length) {
        throw new Error('No token probabilities returned.');
      }
      return data;
    }

    function safeTokenLabel(token) {
      return token
        .replace(/\n/g, '\\n')
        .replace(/\t/g, '\\t')
        .replace(/ /g, '.');
    }

    function nextTokenParamHint() {
      const strategy = $('nextTokenStrategy').value;
      const temperature = 0.9;
      const topP = Number($('pCut').value);
      const topK = Number($('kCut').value);
      if (strategy === 'beam') return 'Using Beam Search with b=4';
      if (strategy === 'topk') return `Using Top-k with k=${topK}`;
      if (strategy === 'topp') return `Using Top-p with p=${topP.toFixed(2)}`;
      if (strategy === 'sample') return `Using Pure Sampling with temp=${temperature.toFixed(2)}`;
      if (strategy === 'chart_click') return 'Using Chart Click with selected token';
      return 'Using Greedy decoding';
    }

    function updateNextStrategyHint() {
      const el = $('nextStrategyHint');
      if (!el) return;
      el.textContent = nextTokenParamHint();
    }

    function drawChartMessage(message) {
      if (typeof Plotly === 'undefined') {
        $('distStatus').textContent = 'Plotly failed to load. Check internet and refresh.';
        return;
      }
      const css = getComputedStyle(document.body);
      const plotBg = css.getPropertyValue('--plot-bg').trim() || '#f4fbf7';
      const paperBg = css.getPropertyValue('--paper-bg').trim() || '#ffffff';
      Plotly.react(tailChartEl, [], {
        margin: { l: 70, r: 20, t: 24, b: 64 },
        xaxis: { visible: false },
        yaxis: { visible: false },
        annotations: [{
          x: 0.5,
          y: 0.5,
          xref: 'paper',
          yref: 'paper',
          showarrow: false,
          text: message,
          font: { size: 16 },
        }],
        paper_bgcolor: paperBg,
        plot_bgcolor: plotBg,
      }, { displayModeBar: true, responsive: true });
    }

    function drawDistribution() {
      if (typeof Plotly === 'undefined') {
        $('distStatus').textContent = 'Plotly failed to load. Check internet and refresh.';
        return;
      }

      const css = getComputedStyle(document.body);
      const plotBg = css.getPropertyValue('--plot-bg').trim() || '#f4fbf7';
      const paperBg = css.getPropertyValue('--paper-bg').trim() || '#ffffff';
      const plotGrid = css.getPropertyValue('--plot-grid').trim() || '#d5e6dc';
      const topKLine = css.getPropertyValue('--topk-line').trim() || '#3e8f66';
      const topPLine = css.getPropertyValue('--topp-line').trim() || '#0057ff';
      const barTopP = css.getPropertyValue('--bar-topp').trim() || 'rgba(47, 141, 96, 0.85)';
      const barTopK = css.getPropertyValue('--bar-topk').trim() || 'rgba(62, 143, 102, 0.70)';
      const barTail = css.getPropertyValue('--bar-tail').trim() || 'rgba(180, 35, 24, 0.28)';

      const probs = distTokens.map((t) => t.prob);
      const kRaw = Number($('kCut').value);
      if (!probs.length) {
        drawChartMessage('No distribution loaded yet.');
        $('nucleusLen').textContent = '0';
        $('topkLen').textContent = '0';
        $('entropyBits').textContent = '0.00';
        return;
      }

      const k = kRaw;
      const shownMass = probs.reduce((a, b) => a + b, 0) || 1;
      const renorm = probs.map((x) => x / shownMass);

      const x = [];
      const y = [];
      const text = [];
      const color = [];

      let cumulative = 0;
      let pLen = Number(distMeta.top_p_rank || 0);
      for (let i = 0; i < probs.length; i += 1) {
        cumulative += renorm[i];
        const rank = Number(distTokens[i]?.rank || i + 1);
        const inTopK = rank <= k;
        const inTopP = rank <= pLen;
        x.push(i + 1);
        y.push(probs[i] * 100);
        text.push([
          `Token: ${safeTokenLabel(distTokens[i].token)}`,
          `Rank: ${i + 1}`,
          `Prob: ${(probs[i] * 100).toFixed(3)}%`,
          `Cumulative: ${(cumulative * 100).toFixed(2)}%`,
          `Top-k: ${inTopK ? 'yes' : 'no'}`,
          `Top-p: ${inTopP ? 'yes' : 'no'}`,
        ].join('<br>'));
        color.push(inTopP ? barTopP : (inTopK ? barTopK : barTail));
      }

      const tickStep = Math.max(1, Math.ceil(x.length / 24));
      const tickVals = [];
      const tickText = [];
      for (let i = 0; i < x.length; i += tickStep) {
        tickVals.push(i + 1);
        tickText.push(safeTokenLabel(distTokens[i].token));
      }

      const yMax = Math.max(...y) * 1.12;
      const kBoundaryX = Math.min(k + 0.5, x.length + 0.5);
      const pBoundaryX = Math.min(pLen + 0.5, x.length + 0.5);
      const topPBoundaryX = Math.abs(pBoundaryX - kBoundaryX) < 0.2 ? (pBoundaryX + 0.18) : pBoundaryX;

      Plotly.react(
        tailChartEl,
        [{
          type: 'bar',
          x,
          y,
          marker: { color, line: { width: 0 } },
          customdata: text,
          hovertemplate: '%{customdata}<extra></extra>',
        }],
        {
          margin: { l: 78, r: 20, t: 28, b: 110 },
          paper_bgcolor: paperBg,
          plot_bgcolor: plotBg,
          clickmode: 'event+select',
          xaxis: {
            title: 'Token Rank (hover for exact token labels)',
            tickmode: 'array',
            tickvals: tickVals,
            ticktext: tickText,
            tickangle: -24,
            showgrid: false,
          },
          yaxis: {
            title: 'Probability (%)',
            rangemode: 'tozero',
            gridcolor: plotGrid,
          },
          shapes: [
            {
              type: 'line',
              x0: kBoundaryX,
              x1: kBoundaryX,
              y0: 0,
              y1: yMax,
              line: { color: topKLine, width: 2, dash: 'dash' },
            },
            {
              type: 'line',
              x0: topPBoundaryX,
              x1: topPBoundaryX,
              y0: 0,
              y1: yMax,
              line: { color: topPLine, width: 5, dash: 'solid' },
            },
          ],
          annotations: [
            {
              x: kBoundaryX,
              y: yMax * 0.95,
              text: k <= x.length ? `Top-k boundary (k=${k})` : `Top-k boundary (k=${k}, off-chart)`,
              showarrow: false,
              font: { size: 11, color: topKLine },
            },
            {
              x: topPBoundaryX,
              y: yMax,
              text: pLen <= x.length ? `Top-p boundary (n=${pLen})` : `Top-p boundary (n=${pLen}, off-chart)`,
              showarrow: false,
              font: { size: 12, color: topPLine },
            },
          ],
          hoverlabel: {
            bgcolor: '#121b2d',
            font: { color: '#eef4ff', size: 12 },
          },
        },
        {
          displayModeBar: true,
          responsive: true,
          modeBarButtonsToRemove: ['lasso2d', 'select2d'],
        }
      );
      bindChartTokenSelect();

      const entropy = renorm.reduce((acc, p) => (p > 0 ? acc - p * Math.log2(p) : acc), 0);
      $('nucleusLen').textContent = String(pLen);
      $('topkLen').textContent = String(k);
      $('entropyBits').textContent = entropy.toFixed(2);
    }

    async function fetchRealDistribution() {
      if (distInFlight) {
        pendingDistRefresh = true;
        return;
      }
      distInFlight = true;
      $('generateNextToken').disabled = true;
      $('distStatus').textContent = 'Loading distribution...';
      drawChartMessage('Loading distribution...');

      try {
        const prompt = $('distPrompt').value.trim() || 'The report found that';
        const topN = Number($('distN').value);
        const dist = await fetchDistribution(prompt, topN);
        distTokens = dist.tokens;
        distMeta = {
          top_k_rank: Number($('kCut').value),
          top_p_rank: Number(dist.top_p_rank || 0),
          vocab_size: Number(dist.vocab_size || 0),
        };
        drawDistribution();
        $('distStatus').textContent = 'Distribution loaded.';
      } catch (err) {
        $('distStatus').textContent = `Failed: ${err.message}`;
      } finally {
        $('generateNextToken').disabled = false;
        distInFlight = false;
        if (pendingDistRefresh) {
          pendingDistRefresh = false;
          fetchRealDistribution();
        }
      }
    }

    function bindChartTokenSelect() {
      if (typeof tailChartEl.on !== 'function') return;
      if (typeof tailChartEl.removeAllListeners === 'function') {
        tailChartEl.removeAllListeners('plotly_click');
      }
      tailChartEl.on('plotly_click', async (evt) => {
        const idx = evt?.points?.[0]?.pointIndex;
        if (idx == null || !distTokens[idx]) return;
        const token = distTokens[idx].token || '';
        if (!token) return;
        selectedChartToken = token;
        $('selectedTokenStatus').textContent = `Selected: ${safeTokenLabel(token)}`;
      });
    }

    function undoLastToken() {
      if (!distPromptHistory.length) {
        $('nextTokenStatus').textContent = 'Nothing to undo.';
        return;
      }
      $('distPrompt').value = distPromptHistory.pop();
      $('nextTokenStatus').textContent = 'Undid last token update.';
      scheduleDistRefresh(200);
    }

    function scheduleDistRefresh(delayMs = 350) {
      if (distRefreshTimer) clearTimeout(distRefreshTimer);
      distRefreshTimer = setTimeout(() => {
        fetchRealDistribution();
      }, delayMs);
    }

    async function generateNextToken() {
      if (distInFlight) return;
      $('nextTokenStatus').textContent = 'Generating next token...';
      $('generateNextToken').disabled = true;
      try {
        const prompt = $('distPrompt').value.trim() || 'The report found that';
        const strategy = $('nextTokenStrategy').value;
        const temperature = 0.9;
        const topP = Number($('pCut').value);
        const topK = Number($('kCut').value);
        const beamSize = 4;
        const body = {
          model: apiConfig().model,
          prompt,
          max_tokens: 1,
          strategy,
        };
        if (strategy === 'greedy') {
          body.temperature = 0;
          body.top_p = 1;
        } else if (strategy === 'beam') {
          body.temperature = 0;
          body.top_p = 1;
          body.beam_size = Math.max(1, beamSize || 4);
        } else if (strategy === 'topk') {
          body.temperature = temperature;
          body.top_p = 1;
          body.top_k = topK;
        } else if (strategy === 'sample') {
          body.temperature = temperature;
          body.top_p = 1;
        } else if (strategy === 'topp') {
          body.temperature = temperature;
          body.top_p = topP;
        } else if (strategy !== 'chart_click') {
          throw new Error(`Unsupported strategy: ${strategy}`);
        }
        let token = '';
        if (strategy === 'chart_click') {
          token = selectedChartToken;
          if (!token) throw new Error('Select a token from the chart first.');
          selectedChartToken = '';
          $('selectedTokenStatus').textContent = 'Selection consumed. Click a new token on the chart.';
        } else {
          const res = await fetch('/api/local/completions', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body),
          });
          if (!res.ok) throw new Error(`HTTP ${res.status}: ${(await res.text()).slice(0, 220)}`);
          const data = await res.json();
          token = data?.choices?.[0]?.text || '';
          if (!token) throw new Error('No token returned.');
        }
        distPromptHistory.push(prompt);
        $('distPrompt').value = `${prompt}${token}`;
        const strategyName =
          strategy === 'chart_click' ? 'chart-click' :
          strategy === 'beam' ? 'beam-search' :
          strategy === 'sample' ? 'pure-sampling' :
          strategy === 'topp' ? 'top-p' :
          strategy === 'topk' ? 'top-k' : 'greedy';
        const strategyParams =
          strategy === 'beam' ? `b=${body.beam_size}` :
          strategy === 'topk' ? `k=${topK}, temp=${temperature.toFixed(2)}` :
          strategy === 'topp' ? `p=${topP.toFixed(2)}, temp=${temperature.toFixed(2)}` :
          strategy === 'sample' ? `temp=${temperature.toFixed(2)}` :
          strategy === 'chart_click' ? 'manual chart token' : 'deterministic';
        $('nextTokenStatus').textContent = `Added token (${strategyName}; ${strategyParams}): ${safeTokenLabel(token)}`;
        await fetchRealDistribution();
      } catch (err) {
        $('nextTokenStatus').textContent = `Failed: ${err.message}`;
      } finally {
        $('generateNextToken').disabled = false;
      }
    }

    $('generateNextToken').addEventListener('click', generateNextToken);
    $('undoToken').addEventListener('click', undoLastToken);
    $('distPrompt').addEventListener('input', () => scheduleDistRefresh(450));
    $('kCut').addEventListener('input', drawDistribution);
    $('nextTokenStrategy').addEventListener('change', updateNextStrategyHint);
    $('pCut').addEventListener('input', () => scheduleDistRefresh(220));
    $('pCut').addEventListener('input', updateNextStrategyHint);
    $('kCut').addEventListener('input', updateNextStrategyHint);
    $('distN').addEventListener('change', fetchRealDistribution);
    window.addEventListener('resize', drawDistribution);

    updateSampleTitle('a');
    updateSampleTitle('b');
    updateMethodControls('a');
    updateMethodControls('b');
    updateWmControls();
    try {
      const savedTheme = localStorage.getItem('decoding_theme') || 'forest';
      $('themeSelect').value = savedTheme;
      applyTheme(savedTheme);
    } catch (_) {
      applyTheme('forest');
    }
    $('arenaStatus').textContent = 'Ready.';
    $('distStatus').textContent = 'Ready.';
    updateNextStrategyHint();
    drawChartMessage('Click "Load Model" or open this tab to load distribution.');

    checkApiServer();
    setTimeout(() => { $('preloadModel').click(); }, 0);
  </script>
</body>
</html>
